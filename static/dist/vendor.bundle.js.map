{"version":3,"sources":["webpack:///vendor.bundle.js","webpack:///webpack/bootstrap 5cc4b7120383228bb2b6","webpack:///./static/src/vendor.es6","webpack:///./~/riot/riot.js","webpack:///./~/superagent/lib/client.js","webpack:///./~/superagent/~/component-emitter/index.js","webpack:///./~/superagent/~/reduce-component/index.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","parentJsonpFunction","window","chunkIds","moreModules","chunkId","i","callbacks","length","installedChunks","push","apply","shift","e","callback","undefined","head","document","getElementsByTagName","script","createElement","type","charset","async","src","p","appendChild","m","c","__WEBPACK_AMD_DEFINE_RESULT__","loopKeys","expr","b0","brackets","els","trim","slice","match","key","pos","val","mkitem","item","_each","dom","parent","remAttr","checksum","tagName","getTagName","template","outerHTML","hasImpl","tagImpl","impl","tmpl","root","parentNode","placeholder","createComment","tags","child","getTag","insertBefore","one","stub","removeChild","on","items","isArray","JSON","stringify","Object","keys","map","frag","createDocumentFragment","j","unmount","splice","_item","update","Tag","isLoop","SPECIAL_TAGS_REGEX","test","cloneNode","innerHTML","mount","walk","node","nodeType","_looped","_visited","setNamed","parseNamedElements","tag","childTags","getAttribute","initChildTag","parseExpressions","expressions","addExpr","extra","indexOf","extend","nodeValue","attr","each","attributes","name","bool","split","value","conf","updateOpts","ctx","self","el","opts","normalizeData","data","T_UNDEF","inheritFromParent","k","mustSync","RESERVED_WORDS_BLACKLIST","propsInSyncWithParent","toggle","isMount","evt","riot","observable","this","inherit","mkdom","cleanUpData","fn","toLowerCase","_tag","isMounted","_id","__uid","replaceYield","T_OBJECT","trigger","mixin","arguments","mix","T_STRING","isFunction","bind","init","attrs","walkAttributes","v","setAttribute","firstChild","isInStub","keepRootTag","ptag","getImmediateCustomParentTag","removeAttribute","off","setEventHandler","handler","event","currentTarget","target","srcElement","which","charCode","keyCode","ignored","preventDefault","returnValue","preventUpdate","insertTo","before","attrName","replace","add","remove","inStub","createTextNode","style","display","startsWith","RIOT_PREFIX","RIOT_TAG","len","T_FUNCTION","cachedTag","namedTag","obj","args","o","nextSibling","html","re","exec","mkEl","$$","selector","querySelectorAll","$","querySelector","Child","prototype","str","injectStyle","css","render","styleNode","styleSheet","cssText","_rendered","body","rs","mountTo","_innerHTML","virtualDom","version","settings","IE_VERSION","documentMode","Array","events","typed","cb","arr","fns","busy","concat","all","mixins","win","hash","loc","href","parser","path","emit","current","location","started","r","route","arg","stop","removeEventListener","detachEvent","start","addEventListener","attachEvent","orig","cachedBrackets","b","x","s","RegExp","source","global","extract","join","Function","n","pair","_","wrap","nonull","reVars","OGLOB","substrings","parts","sub","open","close","level","matches","cache","checkIE","_mkdom","rootTag","rootEls","GENERIC","ie9elem","select","div","tr","th","td","tbody","col","addRiotTags","list","selectAllTags","pushTags","last","allTags","nodeList","_el","util","noop","isHost","toString","isObject","serialize","pairs","encodeURIComponent","parseString","decodeURIComponent","parseHeader","index","line","field","lines","fields","pop","params","reduce","Response","req","options","xhr","text","method","responseType","responseText","statusText","setStatusProperties","status","header","headers","getAllResponseHeaders","getResponseHeader","setHeaderProperties","parseBody","response","Request","url","Emitter","_query","_header","err","res","Error","parse","original","new_err","request","end","getXHR","XMLHttpRequest","protocol","ActiveXObject","serializeObject","types","json","xml","urlencoded","form","form-data","application/x-www-form-urlencoded","application/json","get","ct","statusCode","statusType","info","ok","clientError","serverError","error","toError","accepted","noContent","badRequest","unauthorized","notAcceptable","notFound","forbidden","msg","use","timeout","ms","_timeout","clearTimeout","_timer","abort","aborted","set","unset","getHeader","accept","auth","user","pass","btoa","query","_formData","FormData","append","attach","file","filename","send","_data","_callback","crossDomainError","crossDomain","timeoutError","withCredentials","_withCredentials","onreadystatechange","readyState","timedout","handleProgress","total","percent","hasListeners","onprogress","upload","setTimeout","contentType","setRequestHeader","then","fulfill","reject","del","patch","post","put","_callbacks","once","removeListener","removeAllListeners","listeners","initial","idx","curr"],"mappings":"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","file":"vendor.bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// install a JSONP callback for chunk loading\n/******/ \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n/******/ \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n/******/ \t\t// add \"moreModules\" to the modules object,\n/******/ \t\t// then flag all \"chunkIds\" as loaded and fire callback\n/******/ \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n/******/ \t\tfor(;i < chunkIds.length; i++) {\n/******/ \t\t\tchunkId = chunkIds[i];\n/******/ \t\t\tif(installedChunks[chunkId])\n/******/ \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n/******/ \t\t\tinstalledChunks[chunkId] = 0;\n/******/ \t\t}\n/******/ \t\tfor(moduleId in moreModules) {\n/******/ \t\t\tmodules[moduleId] = moreModules[moduleId];\n/******/ \t\t}\n/******/ \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n/******/ \t\twhile(callbacks.length)\n/******/ \t\t\tcallbacks.shift().call(null, __webpack_require__);\n/******/ \t\tif(moreModules[0]) {\n/******/ \t\t\tinstalledModules[0] = 0;\n/******/ \t\t\treturn __webpack_require__(0);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// object to store loaded and loading chunks\n/******/ \t// \"0\" means \"already loaded\"\n/******/ \t// Array means \"loading\", array contains callbacks\n/******/ \tvar installedChunks = {\n/******/ \t\t0:0\n/******/ \t};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/ \t// This file contains only the entry chunk.\n/******/ \t// The chunk loading function for additional chunks\n/******/ \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n/******/ \t\t// \"0\" is the signal for \"already loaded\"\n/******/ \t\tif(installedChunks[chunkId] === 0)\n/******/ \t\t\treturn callback.call(null, __webpack_require__);\n/******/\n/******/ \t\t// an array means \"currently loading\".\n/******/ \t\tif(installedChunks[chunkId] !== undefined) {\n/******/ \t\t\tinstalledChunks[chunkId].push(callback);\n/******/ \t\t} else {\n/******/ \t\t\t// start chunk loading\n/******/ \t\t\tinstalledChunks[chunkId] = [callback];\n/******/ \t\t\tvar head = document.getElementsByTagName('head')[0];\n/******/ \t\t\tvar script = document.createElement('script');\n/******/ \t\t\tscript.type = 'text/javascript';\n/******/ \t\t\tscript.charset = 'utf-8';\n/******/ \t\t\tscript.async = true;\n/******/\n/******/ \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".bundle.js\";\n/******/ \t\t\thead.appendChild(script);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/*!*******************************!*\\\n  !*** ./static/src/vendor.es6 ***!\n  \\*******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(/*! riot */ 1);\n\t\n\t__webpack_require__(/*! superagent/lib/client */ 2);\n\n/***/ },\n/* 1 */\n/*!************************!*\\\n  !*** ./~/riot/riot.js ***!\n  \\************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_RESULT__;/* Riot v2.2.4, @license MIT, (c) 2015 Muut Inc. + contributors */\n\t\n\t;(function(window, undefined) {\n\t  'use strict';\n\tvar riot = { version: 'v2.2.4', settings: {} },\n\t  //// be aware, internal usage\n\t\n\t  // counter to give a unique id to all the Tag instances\n\t  __uid = 0,\n\t\n\t  // riot specific prefixes\n\t  RIOT_PREFIX = 'riot-',\n\t  RIOT_TAG = RIOT_PREFIX + 'tag',\n\t\n\t  // for typeof == '' comparisons\n\t  T_STRING = 'string',\n\t  T_OBJECT = 'object',\n\t  T_UNDEF  = 'undefined',\n\t  T_FUNCTION = 'function',\n\t  // special native tags that cannot be treated like the others\n\t  SPECIAL_TAGS_REGEX = /^(?:opt(ion|group)|tbody|col|t[rhd])$/,\n\t  RESERVED_WORDS_BLACKLIST = ['_item', '_id', 'update', 'root', 'mount', 'unmount', 'mixin', 'isMounted', 'isLoop', 'tags', 'parent', 'opts', 'trigger', 'on', 'off', 'one'],\n\t\n\t  // version# for IE 8-11, 0 for others\n\t  IE_VERSION = (window && window.document || {}).documentMode | 0,\n\t\n\t  // Array.isArray for IE8 is in the polyfills\n\t  isArray = Array.isArray\n\t\n\triot.observable = function(el) {\n\t\n\t  el = el || {}\n\t\n\t  var callbacks = {},\n\t      _id = 0\n\t\n\t  el.on = function(events, fn) {\n\t    if (isFunction(fn)) {\n\t      if (typeof fn.id === T_UNDEF) fn._id = _id++\n\t\n\t      events.replace(/\\S+/g, function(name, pos) {\n\t        (callbacks[name] = callbacks[name] || []).push(fn)\n\t        fn.typed = pos > 0\n\t      })\n\t    }\n\t    return el\n\t  }\n\t\n\t  el.off = function(events, fn) {\n\t    if (events == '*') callbacks = {}\n\t    else {\n\t      events.replace(/\\S+/g, function(name) {\n\t        if (fn) {\n\t          var arr = callbacks[name]\n\t          for (var i = 0, cb; (cb = arr && arr[i]); ++i) {\n\t            if (cb._id == fn._id) arr.splice(i--, 1)\n\t          }\n\t        } else {\n\t          callbacks[name] = []\n\t        }\n\t      })\n\t    }\n\t    return el\n\t  }\n\t\n\t  // only single event supported\n\t  el.one = function(name, fn) {\n\t    function on() {\n\t      el.off(name, on)\n\t      fn.apply(el, arguments)\n\t    }\n\t    return el.on(name, on)\n\t  }\n\t\n\t  el.trigger = function(name) {\n\t    var args = [].slice.call(arguments, 1),\n\t        fns = callbacks[name] || []\n\t\n\t    for (var i = 0, fn; (fn = fns[i]); ++i) {\n\t      if (!fn.busy) {\n\t        fn.busy = 1\n\t        fn.apply(el, fn.typed ? [name].concat(args) : args)\n\t        if (fns[i] !== fn) { i-- }\n\t        fn.busy = 0\n\t      }\n\t    }\n\t\n\t    if (callbacks.all && name != 'all') {\n\t      el.trigger.apply(el, ['all', name].concat(args))\n\t    }\n\t\n\t    return el\n\t  }\n\t\n\t  return el\n\t\n\t}\n\triot.mixin = (function() {\n\t  var mixins = {}\n\t\n\t  return function(name, mixin) {\n\t    if (!mixin) return mixins[name]\n\t    mixins[name] = mixin\n\t  }\n\t\n\t})()\n\t\n\t;(function(riot, evt, win) {\n\t\n\t  // browsers only\n\t  if (!win) return\n\t\n\t  var loc = win.location,\n\t      fns = riot.observable(),\n\t      started = false,\n\t      current\n\t\n\t  function hash() {\n\t    return loc.href.split('#')[1] || ''   // why not loc.hash.splice(1) ?\n\t  }\n\t\n\t  function parser(path) {\n\t    return path.split('/')\n\t  }\n\t\n\t  function emit(path) {\n\t    if (path.type) path = hash()\n\t\n\t    if (path != current) {\n\t      fns.trigger.apply(null, ['H'].concat(parser(path)))\n\t      current = path\n\t    }\n\t  }\n\t\n\t  var r = riot.route = function(arg) {\n\t    // string\n\t    if (arg[0]) {\n\t      loc.hash = arg\n\t      emit(arg)\n\t\n\t    // function\n\t    } else {\n\t      fns.on('H', arg)\n\t    }\n\t  }\n\t\n\t  r.exec = function(fn) {\n\t    fn.apply(null, parser(hash()))\n\t  }\n\t\n\t  r.parser = function(fn) {\n\t    parser = fn\n\t  }\n\t\n\t  r.stop = function () {\n\t    if (started) {\n\t      if (win.removeEventListener) win.removeEventListener(evt, emit, false) //@IE8 - the if()\n\t      else win.detachEvent('on' + evt, emit) //@IE8\n\t      fns.off('*')\n\t      started = false\n\t    }\n\t  }\n\t\n\t  r.start = function () {\n\t    if (!started) {\n\t      if (win.addEventListener) win.addEventListener(evt, emit, false) //@IE8 - the if()\n\t      else win.attachEvent('on' + evt, emit) //IE8\n\t      started = true\n\t    }\n\t  }\n\t\n\t  // autostart the router\n\t  r.start()\n\t\n\t})(riot, 'hashchange', window)\n\t/*\n\t\n\t//// How it works?\n\t\n\t\n\tThree ways:\n\t\n\t1. Expressions: tmpl('{ value }', data).\n\t   Returns the result of evaluated expression as a raw object.\n\t\n\t2. Templates: tmpl('Hi { name } { surname }', data).\n\t   Returns a string with evaluated expressions.\n\t\n\t3. Filters: tmpl('{ show: !done, highlight: active }', data).\n\t   Returns a space separated list of trueish keys (mainly\n\t   used for setting html classes), e.g. \"show highlight\".\n\t\n\t\n\t// Template examples\n\t\n\ttmpl('{ title || \"Untitled\" }', data)\n\ttmpl('Results are { results ? \"ready\" : \"loading\" }', data)\n\ttmpl('Today is { new Date() }', data)\n\ttmpl('{ message.length > 140 && \"Message is too long\" }', data)\n\ttmpl('This item got { Math.round(rating) } stars', data)\n\ttmpl('<h1>{ title }</h1>{ body }', data)\n\t\n\t\n\t// Falsy expressions in templates\n\t\n\tIn templates (as opposed to single expressions) all falsy values\n\texcept zero (undefined/null/false) will default to empty string:\n\t\n\ttmpl('{ undefined } - { false } - { null } - { 0 }', {})\n\t// will return: \" - - - 0\"\n\t\n\t*/\n\t\n\t\n\tvar brackets = (function(orig) {\n\t\n\t  var cachedBrackets,\n\t      r,\n\t      b,\n\t      re = /[{}]/g\n\t\n\t  return function(x) {\n\t\n\t    // make sure we use the current setting\n\t    var s = riot.settings.brackets || orig\n\t\n\t    // recreate cached vars if needed\n\t    if (cachedBrackets !== s) {\n\t      cachedBrackets = s\n\t      b = s.split(' ')\n\t      r = b.map(function (e) { return e.replace(/(?=.)/g, '\\\\') })\n\t    }\n\t\n\t    // if regexp given, rewrite it with current brackets (only if differ from default)\n\t    return x instanceof RegExp ? (\n\t        s === orig ? x :\n\t        new RegExp(x.source.replace(re, function(b) { return r[~~(b === '}')] }), x.global ? 'g' : '')\n\t      ) :\n\t      // else, get specific bracket\n\t      b[x]\n\t  }\n\t})('{ }')\n\t\n\t\n\tvar tmpl = (function() {\n\t\n\t  var cache = {},\n\t      OGLOB = '\"in d?d:' + (window ? 'window).' : 'global).'),\n\t      reVars =\n\t      /(['\"\\/])(?:[^\\\\]*?|\\\\.|.)*?\\1|\\.\\w*|\\w*:|\\b(?:(?:new|typeof|in|instanceof) |(?:this|true|false|null|undefined)\\b|function\\s*\\()|([A-Za-z_$]\\w*)/g\n\t\n\t  // build a template (or get it from cache), render with data\n\t  return function(str, data) {\n\t    return str && (cache[str] || (cache[str] = tmpl(str)))(data)\n\t  }\n\t\n\t\n\t  // create a template instance\n\t\n\t  function tmpl(s, p) {\n\t\n\t    if (s.indexOf(brackets(0)) < 0) {\n\t      // return raw text\n\t      s = s.replace(/\\n|\\r\\n?/g, '\\n')\n\t      return function () { return s }\n\t    }\n\t\n\t    // temporarily convert \\{ and \\} to a non-character\n\t    s = s\n\t      .replace(brackets(/\\\\{/g), '\\uFFF0')\n\t      .replace(brackets(/\\\\}/g), '\\uFFF1')\n\t\n\t    // split string to expression and non-expresion parts\n\t    p = split(s, extract(s, brackets(/{/), brackets(/}/)))\n\t\n\t    // is it a single expression or a template? i.e. {x} or <b>{x}</b>\n\t    s = (p.length === 2 && !p[0]) ?\n\t\n\t      // if expression, evaluate it\n\t      expr(p[1]) :\n\t\n\t      // if template, evaluate all expressions in it\n\t      '[' + p.map(function(s, i) {\n\t\n\t        // is it an expression or a string (every second part is an expression)\n\t        return i % 2 ?\n\t\n\t          // evaluate the expressions\n\t          expr(s, true) :\n\t\n\t          // process string parts of the template:\n\t          '\"' + s\n\t\n\t            // preserve new lines\n\t            .replace(/\\n|\\r\\n?/g, '\\\\n')\n\t\n\t            // escape quotes\n\t            .replace(/\"/g, '\\\\\"') +\n\t\n\t          '\"'\n\t\n\t      }).join(',') + '].join(\"\")'\n\t\n\t    return new Function('d', 'return ' + s\n\t      // bring escaped { and } back\n\t      .replace(/\\uFFF0/g, brackets(0))\n\t      .replace(/\\uFFF1/g, brackets(1)) + ';')\n\t\n\t  }\n\t\n\t\n\t  // parse { ... } expression\n\t\n\t  function expr(s, n) {\n\t    s = s\n\t\n\t      // convert new lines to spaces\n\t      .replace(/\\n|\\r\\n?/g, ' ')\n\t\n\t      // trim whitespace, brackets, strip comments\n\t      .replace(brackets(/^[{ ]+|[ }]+$|\\/\\*.+?\\*\\//g), '')\n\t\n\t    // is it an object literal? i.e. { key : value }\n\t    return /^\\s*[\\w- \"']+ *:/.test(s) ?\n\t\n\t      // if object literal, return trueish keys\n\t      // e.g.: { show: isOpen(), done: item.done } -> \"show done\"\n\t      '[' +\n\t\n\t          // extract key:val pairs, ignoring any nested objects\n\t          extract(s,\n\t\n\t              // name part: name:, \"name\":, 'name':, name :\n\t              /[\"' ]*[\\w- ]+[\"' ]*:/,\n\t\n\t              // expression part: everything upto a comma followed by a name (see above) or end of line\n\t              /,(?=[\"' ]*[\\w- ]+[\"' ]*:)|}|$/\n\t              ).map(function(pair) {\n\t\n\t                // get key, val parts\n\t                return pair.replace(/^[ \"']*(.+?)[ \"']*: *(.+?),? *$/, function(_, k, v) {\n\t\n\t                  // wrap all conditional parts to ignore errors\n\t                  return v.replace(/[^&|=!><]+/g, wrap) + '?\"' + k + '\":\"\",'\n\t\n\t                })\n\t\n\t              }).join('') +\n\t\n\t        '].join(\" \").trim()' :\n\t\n\t      // if js expression, evaluate as javascript\n\t      wrap(s, n)\n\t\n\t  }\n\t\n\t\n\t  // execute js w/o breaking on errors or undefined vars\n\t\n\t  function wrap(s, nonull) {\n\t    s = s.trim()\n\t    return !s ? '' : '(function(v){try{v=' +\n\t\n\t      // prefix vars (name => data.name)\n\t      s.replace(reVars, function(s, _, v) { return v ? '((\"' + v + OGLOB + v + ')' : s }) +\n\t\n\t      // default to empty string for falsy values except zero\n\t      '}catch(e){}return ' + (nonull === true ? '!v&&v!==0?\"\":v' : 'v') + '}).call(d)'\n\t  }\n\t\n\t\n\t  // split string by an array of substrings\n\t\n\t  function split(str, substrings) {\n\t    var parts = []\n\t    substrings.map(function(sub, i) {\n\t\n\t      // push matched expression and part before it\n\t      i = str.indexOf(sub)\n\t      parts.push(str.slice(0, i), sub)\n\t      str = str.slice(i + sub.length)\n\t    })\n\t    if (str) parts.push(str)\n\t\n\t    // push the remaining part\n\t    return parts\n\t  }\n\t\n\t\n\t  // match strings between opening and closing regexp, skipping any inner/nested matches\n\t\n\t  function extract(str, open, close) {\n\t\n\t    var start,\n\t        level = 0,\n\t        matches = [],\n\t        re = new RegExp('(' + open.source + ')|(' + close.source + ')', 'g')\n\t\n\t    str.replace(re, function(_, open, close, pos) {\n\t\n\t      // if outer inner bracket, mark position\n\t      if (!level && open) start = pos\n\t\n\t      // in(de)crease bracket level\n\t      level += open ? 1 : -1\n\t\n\t      // if outer closing bracket, grab the match\n\t      if (!level && close != null) matches.push(str.slice(start, pos + close.length))\n\t\n\t    })\n\t\n\t    return matches\n\t  }\n\t\n\t})()\n\t\n\t/*\n\t  lib/browser/tag/mkdom.js\n\t\n\t  Includes hacks needed for the Internet Explorer version 9 and bellow\n\t\n\t*/\n\t// http://kangax.github.io/compat-table/es5/#ie8\n\t// http://codeplanet.io/dropping-ie8/\n\t\n\tvar mkdom = (function (checkIE) {\n\t\n\t  var rootEls = {\n\t        'tr': 'tbody',\n\t        'th': 'tr',\n\t        'td': 'tr',\n\t        'tbody': 'table',\n\t        'col': 'colgroup'\n\t      },\n\t      GENERIC = 'div'\n\t\n\t  checkIE = checkIE && checkIE < 10\n\t\n\t  // creates any dom element in a div, table, or colgroup container\n\t  function _mkdom(html) {\n\t\n\t    var match = html && html.match(/^\\s*<([-\\w]+)/),\n\t        tagName = match && match[1].toLowerCase(),\n\t        rootTag = rootEls[tagName] || GENERIC,\n\t        el = mkEl(rootTag)\n\t\n\t    el.stub = true\n\t\n\t    if (checkIE && tagName && (match = tagName.match(SPECIAL_TAGS_REGEX)))\n\t      ie9elem(el, html, tagName, !!match[1])\n\t    else\n\t      el.innerHTML = html\n\t\n\t    return el\n\t  }\n\t\n\t  // creates tr, th, td, option, optgroup element for IE8-9\n\t  /* istanbul ignore next */\n\t  function ie9elem(el, html, tagName, select) {\n\t\n\t    var div = mkEl(GENERIC),\n\t        tag = select ? 'select>' : 'table>',\n\t        child\n\t\n\t    div.innerHTML = '<' + tag + html + '</' + tag\n\t\n\t    child = div.getElementsByTagName(tagName)[0]\n\t    if (child)\n\t      el.appendChild(child)\n\t\n\t  }\n\t  // end ie9elem()\n\t\n\t  return _mkdom\n\t\n\t})(IE_VERSION)\n\t\n\t// { key, i in items} -> { key, i, items }\n\tfunction loopKeys(expr) {\n\t  var b0 = brackets(0),\n\t      els = expr.trim().slice(b0.length).match(/^\\s*(\\S+?)\\s*(?:,\\s*(\\S+))?\\s+in\\s+(.+)$/)\n\t  return els ? { key: els[1], pos: els[2], val: b0 + els[3] } : { val: expr }\n\t}\n\t\n\tfunction mkitem(expr, key, val) {\n\t  var item = {}\n\t  item[expr.key] = key\n\t  if (expr.pos) item[expr.pos] = val\n\t  return item\n\t}\n\t\n\t\n\t/* Beware: heavy stuff */\n\tfunction _each(dom, parent, expr) {\n\t\n\t  remAttr(dom, 'each')\n\t\n\t  var tagName = getTagName(dom),\n\t      template = dom.outerHTML,\n\t      hasImpl = !!tagImpl[tagName],\n\t      impl = tagImpl[tagName] || {\n\t        tmpl: template\n\t      },\n\t      root = dom.parentNode,\n\t      placeholder = document.createComment('riot placeholder'),\n\t      tags = [],\n\t      child = getTag(dom),\n\t      checksum\n\t\n\t  root.insertBefore(placeholder, dom)\n\t\n\t  expr = loopKeys(expr)\n\t\n\t  // clean template code\n\t  parent\n\t    .one('premount', function () {\n\t      if (root.stub) root = parent.root\n\t      // remove the original DOM node\n\t      dom.parentNode.removeChild(dom)\n\t    })\n\t    .on('update', function () {\n\t      var items = tmpl(expr.val, parent)\n\t\n\t      // object loop. any changes cause full redraw\n\t      if (!isArray(items)) {\n\t\n\t        checksum = items ? JSON.stringify(items) : ''\n\t\n\t        items = !items ? [] :\n\t          Object.keys(items).map(function (key) {\n\t            return mkitem(expr, key, items[key])\n\t          })\n\t      }\n\t\n\t      var frag = document.createDocumentFragment(),\n\t          i = tags.length,\n\t          j = items.length\n\t\n\t      // unmount leftover items\n\t      while (i > j) {\n\t        tags[--i].unmount()\n\t        tags.splice(i, 1)\n\t      }\n\t\n\t      for (i = 0; i < j; ++i) {\n\t        var _item = !checksum && !!expr.key ? mkitem(expr, items[i], i) : items[i]\n\t\n\t        if (!tags[i]) {\n\t          // mount new\n\t          (tags[i] = new Tag(impl, {\n\t              parent: parent,\n\t              isLoop: true,\n\t              hasImpl: hasImpl,\n\t              root: SPECIAL_TAGS_REGEX.test(tagName) ? root : dom.cloneNode(),\n\t              item: _item\n\t            }, dom.innerHTML)\n\t          ).mount()\n\t\n\t          frag.appendChild(tags[i].root)\n\t        } else\n\t          tags[i].update(_item)\n\t\n\t        tags[i]._item = _item\n\t\n\t      }\n\t\n\t      root.insertBefore(frag, placeholder)\n\t\n\t      if (child) parent.tags[tagName] = tags\n\t\n\t    }).one('updated', function() {\n\t      var keys = Object.keys(parent)// only set new values\n\t      walk(root, function(node) {\n\t        // only set element node and not isLoop\n\t        if (node.nodeType == 1 && !node.isLoop && !node._looped) {\n\t          node._visited = false // reset _visited for loop node\n\t          node._looped = true // avoid set multiple each\n\t          setNamed(node, parent, keys)\n\t        }\n\t      })\n\t    })\n\t\n\t}\n\t\n\t\n\tfunction parseNamedElements(root, tag, childTags) {\n\t\n\t  walk(root, function(dom) {\n\t    if (dom.nodeType == 1) {\n\t      dom.isLoop = dom.isLoop || (dom.parentNode && dom.parentNode.isLoop || dom.getAttribute('each')) ? 1 : 0\n\t\n\t      // custom child tag\n\t      var child = getTag(dom)\n\t\n\t      if (child && !dom.isLoop) {\n\t        childTags.push(initChildTag(child, dom, tag))\n\t      }\n\t\n\t      if (!dom.isLoop)\n\t        setNamed(dom, tag, [])\n\t    }\n\t\n\t  })\n\t\n\t}\n\t\n\tfunction parseExpressions(root, tag, expressions) {\n\t\n\t  function addExpr(dom, val, extra) {\n\t    if (val.indexOf(brackets(0)) >= 0) {\n\t      var expr = { dom: dom, expr: val }\n\t      expressions.push(extend(expr, extra))\n\t    }\n\t  }\n\t\n\t  walk(root, function(dom) {\n\t    var type = dom.nodeType\n\t\n\t    // text node\n\t    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n\t    if (type != 1) return\n\t\n\t    /* element */\n\t\n\t    // loop\n\t    var attr = dom.getAttribute('each')\n\t\n\t    if (attr) { _each(dom, tag, attr); return false }\n\t\n\t    // attribute expressions\n\t    each(dom.attributes, function(attr) {\n\t      var name = attr.name,\n\t        bool = name.split('__')[1]\n\t\n\t      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n\t      if (bool) { remAttr(dom, name); return false }\n\t\n\t    })\n\t\n\t    // skip custom tags\n\t    if (getTag(dom)) return false\n\t\n\t  })\n\t\n\t}\n\tfunction Tag(impl, conf, innerHTML) {\n\t\n\t  var self = riot.observable(this),\n\t      opts = inherit(conf.opts) || {},\n\t      dom = mkdom(impl.tmpl),\n\t      parent = conf.parent,\n\t      isLoop = conf.isLoop,\n\t      hasImpl = conf.hasImpl,\n\t      item = cleanUpData(conf.item),\n\t      expressions = [],\n\t      childTags = [],\n\t      root = conf.root,\n\t      fn = impl.fn,\n\t      tagName = root.tagName.toLowerCase(),\n\t      attr = {},\n\t      propsInSyncWithParent = []\n\t\n\t  if (fn && root._tag) {\n\t    root._tag.unmount(true)\n\t  }\n\t\n\t  // not yet mounted\n\t  this.isMounted = false\n\t  root.isLoop = isLoop\n\t\n\t  // keep a reference to the tag just created\n\t  // so we will be able to mount this tag multiple times\n\t  root._tag = this\n\t\n\t  // create a unique id to this tag\n\t  // it could be handy to use it also to improve the virtual dom rendering speed\n\t  this._id = __uid++\n\t\n\t  extend(this, { parent: parent, root: root, opts: opts, tags: {} }, item)\n\t\n\t  // grab attributes\n\t  each(root.attributes, function(el) {\n\t    var val = el.value\n\t    // remember attributes with expressions only\n\t    if (brackets(/{.*}/).test(val)) attr[el.name] = val\n\t  })\n\t\n\t  if (dom.innerHTML && !/^(select|optgroup|table|tbody|tr|col(?:group)?)$/.test(tagName))\n\t    // replace all the yield tags with the tag inner html\n\t    dom.innerHTML = replaceYield(dom.innerHTML, innerHTML)\n\t\n\t  // options\n\t  function updateOpts() {\n\t    var ctx = hasImpl && isLoop ? self : parent || self\n\t\n\t    // update opts from current DOM attributes\n\t    each(root.attributes, function(el) {\n\t      opts[el.name] = tmpl(el.value, ctx)\n\t    })\n\t    // recover those with expressions\n\t    each(Object.keys(attr), function(name) {\n\t      opts[name] = tmpl(attr[name], ctx)\n\t    })\n\t  }\n\t\n\t  function normalizeData(data) {\n\t    for (var key in item) {\n\t      if (typeof self[key] !== T_UNDEF)\n\t        self[key] = data[key]\n\t    }\n\t  }\n\t\n\t  function inheritFromParent () {\n\t    if (!self.parent || !isLoop) return\n\t    each(Object.keys(self.parent), function(k) {\n\t      // some properties must be always in sync with the parent tag\n\t      var mustSync = !~RESERVED_WORDS_BLACKLIST.indexOf(k) && ~propsInSyncWithParent.indexOf(k)\n\t      if (typeof self[k] === T_UNDEF || mustSync) {\n\t        // track the property to keep in sync\n\t        // so we can keep it updated\n\t        if (!mustSync) propsInSyncWithParent.push(k)\n\t        self[k] = self.parent[k]\n\t      }\n\t    })\n\t  }\n\t\n\t  this.update = function(data) {\n\t    // make sure the data passed will not override\n\t    // the component core methods\n\t    data = cleanUpData(data)\n\t    // inherit properties from the parent\n\t    inheritFromParent()\n\t    // normalize the tag properties in case an item object was initially passed\n\t    if (data && typeof item === T_OBJECT) {\n\t      normalizeData(data)\n\t      item = data\n\t    }\n\t    extend(self, data)\n\t    updateOpts()\n\t    self.trigger('update', data)\n\t    update(expressions, self)\n\t    self.trigger('updated')\n\t  }\n\t\n\t  this.mixin = function() {\n\t    each(arguments, function(mix) {\n\t      mix = typeof mix === T_STRING ? riot.mixin(mix) : mix\n\t      each(Object.keys(mix), function(key) {\n\t        // bind methods to self\n\t        if (key != 'init')\n\t          self[key] = isFunction(mix[key]) ? mix[key].bind(self) : mix[key]\n\t      })\n\t      // init method will be called automatically\n\t      if (mix.init) mix.init.bind(self)()\n\t    })\n\t  }\n\t\n\t  this.mount = function() {\n\t\n\t    updateOpts()\n\t\n\t    // initialiation\n\t    if (fn) fn.call(self, opts)\n\t\n\t    // parse layout after init. fn may calculate args for nested custom tags\n\t    parseExpressions(dom, self, expressions)\n\t\n\t    // mount the child tags\n\t    toggle(true)\n\t\n\t    // update the root adding custom attributes coming from the compiler\n\t    // it fixes also #1087\n\t    if (impl.attrs || hasImpl) {\n\t      walkAttributes(impl.attrs, function (k, v) { root.setAttribute(k, v) })\n\t      parseExpressions(self.root, self, expressions)\n\t    }\n\t\n\t    if (!self.parent || isLoop) self.update(item)\n\t\n\t    // internal use only, fixes #403\n\t    self.trigger('premount')\n\t\n\t    if (isLoop && !hasImpl) {\n\t      // update the root attribute for the looped elements\n\t      self.root = root = dom.firstChild\n\t\n\t    } else {\n\t      while (dom.firstChild) root.appendChild(dom.firstChild)\n\t      if (root.stub) self.root = root = parent.root\n\t    }\n\t    // if it's not a child tag we can trigger its mount event\n\t    if (!self.parent || self.parent.isMounted) {\n\t      self.isMounted = true\n\t      self.trigger('mount')\n\t    }\n\t    // otherwise we need to wait that the parent event gets triggered\n\t    else self.parent.one('mount', function() {\n\t      // avoid to trigger the `mount` event for the tags\n\t      // not visible included in an if statement\n\t      if (!isInStub(self.root)) {\n\t        self.parent.isMounted = self.isMounted = true\n\t        self.trigger('mount')\n\t      }\n\t    })\n\t  }\n\t\n\t\n\t  this.unmount = function(keepRootTag) {\n\t    var el = root,\n\t        p = el.parentNode,\n\t        ptag\n\t\n\t    if (p) {\n\t\n\t      if (parent) {\n\t        ptag = getImmediateCustomParentTag(parent)\n\t        // remove this tag from the parent tags object\n\t        // if there are multiple nested tags with same name..\n\t        // remove this element form the array\n\t        if (isArray(ptag.tags[tagName]))\n\t          each(ptag.tags[tagName], function(tag, i) {\n\t            if (tag._id == self._id)\n\t              ptag.tags[tagName].splice(i, 1)\n\t          })\n\t        else\n\t          // otherwise just delete the tag instance\n\t          ptag.tags[tagName] = undefined\n\t      }\n\t\n\t      else\n\t        while (el.firstChild) el.removeChild(el.firstChild)\n\t\n\t      if (!keepRootTag)\n\t        p.removeChild(el)\n\t      else\n\t        // the riot-tag attribute isn't needed anymore, remove it\n\t        p.removeAttribute('riot-tag')\n\t    }\n\t\n\t\n\t    self.trigger('unmount')\n\t    toggle()\n\t    self.off('*')\n\t    // somehow ie8 does not like `delete root._tag`\n\t    root._tag = null\n\t\n\t  }\n\t\n\t  function toggle(isMount) {\n\t\n\t    // mount/unmount children\n\t    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })\n\t\n\t    // listen/unlisten parent (events flow one way from parent to children)\n\t    if (parent) {\n\t      var evt = isMount ? 'on' : 'off'\n\t\n\t      // the loop tags will be always in sync with the parent automatically\n\t      if (isLoop)\n\t        parent[evt]('unmount', self.unmount)\n\t      else\n\t        parent[evt]('update', self.update)[evt]('unmount', self.unmount)\n\t    }\n\t  }\n\t\n\t  // named elements available for fn\n\t  parseNamedElements(dom, this, childTags)\n\t\n\t\n\t}\n\t\n\tfunction setEventHandler(name, handler, dom, tag) {\n\t\n\t  dom[name] = function(e) {\n\t\n\t    var item = tag._item,\n\t        ptag = tag.parent,\n\t        el\n\t\n\t    if (!item)\n\t      while (ptag && !item) {\n\t        item = ptag._item\n\t        ptag = ptag.parent\n\t      }\n\t\n\t    // cross browser event fix\n\t    e = e || window.event\n\t\n\t    // ignore error on some browsers\n\t    try {\n\t      e.currentTarget = dom\n\t      if (!e.target) e.target = e.srcElement\n\t      if (!e.which) e.which = e.charCode || e.keyCode\n\t    } catch (ignored) { /**/ }\n\t\n\t    e.item = item\n\t\n\t    // prevent default behaviour (by default)\n\t    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n\t      if (e.preventDefault) e.preventDefault()\n\t      e.returnValue = false\n\t    }\n\t\n\t    if (!e.preventUpdate) {\n\t      el = item ? getImmediateCustomParentTag(ptag) : tag\n\t      el.update()\n\t    }\n\t\n\t  }\n\t\n\t}\n\t\n\t// used by if- attribute\n\tfunction insertTo(root, node, before) {\n\t  if (root) {\n\t    root.insertBefore(before, node)\n\t    root.removeChild(node)\n\t  }\n\t}\n\t\n\tfunction update(expressions, tag) {\n\t\n\t  each(expressions, function(expr, i) {\n\t\n\t    var dom = expr.dom,\n\t        attrName = expr.attr,\n\t        value = tmpl(expr.expr, tag),\n\t        parent = expr.dom.parentNode\n\t\n\t    if (expr.bool)\n\t      value = value ? attrName : false\n\t    else if (value == null)\n\t      value = ''\n\t\n\t    // leave out riot- prefixes from strings inside textarea\n\t    // fix #815: any value -> string\n\t    if (parent && parent.tagName == 'TEXTAREA') value = ('' + value).replace(/riot-/g, '')\n\t\n\t    // no change\n\t    if (expr.value === value) return\n\t    expr.value = value\n\t\n\t    // text node\n\t    if (!attrName) {\n\t      dom.nodeValue = '' + value    // #815 related\n\t      return\n\t    }\n\t\n\t    // remove original attribute\n\t    remAttr(dom, attrName)\n\t    // event handler\n\t    if (isFunction(value)) {\n\t      setEventHandler(attrName, value, dom, tag)\n\t\n\t    // if- conditional\n\t    } else if (attrName == 'if') {\n\t      var stub = expr.stub,\n\t          add = function() { insertTo(stub.parentNode, stub, dom) },\n\t          remove = function() { insertTo(dom.parentNode, dom, stub) }\n\t\n\t      // add to DOM\n\t      if (value) {\n\t        if (stub) {\n\t          add()\n\t          dom.inStub = false\n\t          // avoid to trigger the mount event if the tags is not visible yet\n\t          // maybe we can optimize this avoiding to mount the tag at all\n\t          if (!isInStub(dom)) {\n\t            walk(dom, function(el) {\n\t              if (el._tag && !el._tag.isMounted) el._tag.isMounted = !!el._tag.trigger('mount')\n\t            })\n\t          }\n\t        }\n\t      // remove from DOM\n\t      } else {\n\t        stub = expr.stub = stub || document.createTextNode('')\n\t        // if the parentNode is defined we can easily replace the tag\n\t        if (dom.parentNode)\n\t          remove()\n\t        else\n\t        // otherwise we need to wait the updated event\n\t          (tag.parent || tag).one('updated', remove)\n\t\n\t        dom.inStub = true\n\t      }\n\t    // show / hide\n\t    } else if (/^(show|hide)$/.test(attrName)) {\n\t      if (attrName == 'hide') value = !value\n\t      dom.style.display = value ? '' : 'none'\n\t\n\t    // field value\n\t    } else if (attrName == 'value') {\n\t      dom.value = value\n\t\n\t    // <img src=\"{ expr }\">\n\t    } else if (startsWith(attrName, RIOT_PREFIX) && attrName != RIOT_TAG) {\n\t      if (value)\n\t        dom.setAttribute(attrName.slice(RIOT_PREFIX.length), value)\n\t\n\t    } else {\n\t      if (expr.bool) {\n\t        dom[attrName] = value\n\t        if (!value) return\n\t      }\n\t\n\t      if (typeof value !== T_OBJECT) dom.setAttribute(attrName, value)\n\t\n\t    }\n\t\n\t  })\n\t\n\t}\n\tfunction each(els, fn) {\n\t  for (var i = 0, len = (els || []).length, el; i < len; i++) {\n\t    el = els[i]\n\t    // return false -> remove current item during loop\n\t    if (el != null && fn(el, i) === false) i--\n\t  }\n\t  return els\n\t}\n\t\n\tfunction isFunction(v) {\n\t  return typeof v === T_FUNCTION || false   // avoid IE problems\n\t}\n\t\n\tfunction remAttr(dom, name) {\n\t  dom.removeAttribute(name)\n\t}\n\t\n\tfunction getTag(dom) {\n\t  return dom.tagName && tagImpl[dom.getAttribute(RIOT_TAG) || dom.tagName.toLowerCase()]\n\t}\n\t\n\tfunction initChildTag(child, dom, parent) {\n\t  var tag = new Tag(child, { root: dom, parent: parent }, dom.innerHTML),\n\t      tagName = getTagName(dom),\n\t      ptag = getImmediateCustomParentTag(parent),\n\t      cachedTag\n\t\n\t  // fix for the parent attribute in the looped elements\n\t  tag.parent = ptag\n\t\n\t  cachedTag = ptag.tags[tagName]\n\t\n\t  // if there are multiple children tags having the same name\n\t  if (cachedTag) {\n\t    // if the parent tags property is not yet an array\n\t    // create it adding the first cached tag\n\t    if (!isArray(cachedTag))\n\t      ptag.tags[tagName] = [cachedTag]\n\t    // add the new nested tag to the array\n\t    if (!~ptag.tags[tagName].indexOf(tag))\n\t      ptag.tags[tagName].push(tag)\n\t  } else {\n\t    ptag.tags[tagName] = tag\n\t  }\n\t\n\t  // empty the child node once we got its template\n\t  // to avoid that its children get compiled multiple times\n\t  dom.innerHTML = ''\n\t\n\t  return tag\n\t}\n\t\n\tfunction getImmediateCustomParentTag(tag) {\n\t  var ptag = tag\n\t  while (!getTag(ptag.root)) {\n\t    if (!ptag.parent) break\n\t    ptag = ptag.parent\n\t  }\n\t  return ptag\n\t}\n\t\n\tfunction getTagName(dom) {\n\t  var child = getTag(dom),\n\t    namedTag = dom.getAttribute('name'),\n\t    tagName = namedTag && namedTag.indexOf(brackets(0)) < 0 ? namedTag : child ? child.name : dom.tagName.toLowerCase()\n\t\n\t  return tagName\n\t}\n\t\n\tfunction extend(src) {\n\t  var obj, args = arguments\n\t  for (var i = 1; i < args.length; ++i) {\n\t    if ((obj = args[i])) {\n\t      for (var key in obj) {      // eslint-disable-line guard-for-in\n\t        src[key] = obj[key]\n\t      }\n\t    }\n\t  }\n\t  return src\n\t}\n\t\n\t// with this function we avoid that the current Tag methods get overridden\n\tfunction cleanUpData(data) {\n\t  if (!(data instanceof Tag) && !(data && typeof data.trigger == T_FUNCTION)) return data\n\t\n\t  var o = {}\n\t  for (var key in data) {\n\t    if (!~RESERVED_WORDS_BLACKLIST.indexOf(key))\n\t      o[key] = data[key]\n\t  }\n\t  return o\n\t}\n\t\n\tfunction walk(dom, fn) {\n\t  if (dom) {\n\t    if (fn(dom) === false) return\n\t    else {\n\t      dom = dom.firstChild\n\t\n\t      while (dom) {\n\t        walk(dom, fn)\n\t        dom = dom.nextSibling\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t// minimize risk: only zero or one _space_ between attr & value\n\tfunction walkAttributes(html, fn) {\n\t  var m,\n\t      re = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g\n\t\n\t  while ((m = re.exec(html))) {\n\t    fn(m[1].toLowerCase(), m[2] || m[3] || m[4])\n\t  }\n\t}\n\t\n\tfunction isInStub(dom) {\n\t  while (dom) {\n\t    if (dom.inStub) return true\n\t    dom = dom.parentNode\n\t  }\n\t  return false\n\t}\n\t\n\tfunction mkEl(name) {\n\t  return document.createElement(name)\n\t}\n\t\n\tfunction replaceYield(tmpl, innerHTML) {\n\t  return tmpl.replace(/<(yield)\\/?>(<\\/\\1>)?/gi, innerHTML || '')\n\t}\n\t\n\tfunction $$(selector, ctx) {\n\t  return (ctx || document).querySelectorAll(selector)\n\t}\n\t\n\tfunction $(selector, ctx) {\n\t  return (ctx || document).querySelector(selector)\n\t}\n\t\n\tfunction inherit(parent) {\n\t  function Child() {}\n\t  Child.prototype = parent\n\t  return new Child()\n\t}\n\t\n\tfunction setNamed(dom, parent, keys) {\n\t  if (dom._visited) return\n\t  var p,\n\t      v = dom.getAttribute('id') || dom.getAttribute('name')\n\t\n\t  if (v) {\n\t    if (keys.indexOf(v) < 0) {\n\t      p = parent[v]\n\t      if (!p)\n\t        parent[v] = dom\n\t      else if (isArray(p))\n\t        p.push(dom)\n\t      else\n\t        parent[v] = [p, dom]\n\t    }\n\t    dom._visited = true\n\t  }\n\t}\n\t\n\t// faster String startsWith alternative\n\tfunction startsWith(src, str) {\n\t  return src.slice(0, str.length) === str\n\t}\n\t\n\t/*\n\t Virtual dom is an array of custom tags on the document.\n\t Updates and unmounts propagate downwards from parent to children.\n\t*/\n\t\n\tvar virtualDom = [],\n\t    tagImpl = {},\n\t    styleNode\n\t\n\tfunction injectStyle(css) {\n\t\n\t  if (riot.render) return // skip injection on the server\n\t\n\t  if (!styleNode) {\n\t    styleNode = mkEl('style')\n\t    styleNode.setAttribute('type', 'text/css')\n\t  }\n\t\n\t  var head = document.head || document.getElementsByTagName('head')[0]\n\t\n\t  if (styleNode.styleSheet)\n\t    styleNode.styleSheet.cssText += css\n\t  else\n\t    styleNode.innerHTML += css\n\t\n\t  if (!styleNode._rendered)\n\t    if (styleNode.styleSheet) {\n\t      document.body.appendChild(styleNode)\n\t    } else {\n\t      var rs = $('style[type=riot]')\n\t      if (rs) {\n\t        rs.parentNode.insertBefore(styleNode, rs)\n\t        rs.parentNode.removeChild(rs)\n\t      } else head.appendChild(styleNode)\n\t\n\t    }\n\t\n\t  styleNode._rendered = true\n\t\n\t}\n\t\n\tfunction mountTo(root, tagName, opts) {\n\t  var tag = tagImpl[tagName],\n\t      // cache the inner HTML to fix #855\n\t      innerHTML = root._innerHTML = root._innerHTML || root.innerHTML\n\t\n\t  // clear the inner html\n\t  root.innerHTML = ''\n\t\n\t  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)\n\t\n\t  if (tag && tag.mount) {\n\t    tag.mount()\n\t    virtualDom.push(tag)\n\t    return tag.on('unmount', function() {\n\t      virtualDom.splice(virtualDom.indexOf(tag), 1)\n\t    })\n\t  }\n\t\n\t}\n\t\n\triot.tag = function(name, html, css, attrs, fn) {\n\t  if (isFunction(attrs)) {\n\t    fn = attrs\n\t    if (/^[\\w\\-]+\\s?=/.test(css)) {\n\t      attrs = css\n\t      css = ''\n\t    } else attrs = ''\n\t  }\n\t  if (css) {\n\t    if (isFunction(css)) fn = css\n\t    else injectStyle(css)\n\t  }\n\t  tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n\t  return name\n\t}\n\t\n\triot.mount = function(selector, tagName, opts) {\n\t\n\t  var els,\n\t      allTags,\n\t      tags = []\n\t\n\t  // helper functions\n\t\n\t  function addRiotTags(arr) {\n\t    var list = ''\n\t    each(arr, function (e) {\n\t      list += ', *[' + RIOT_TAG + '=\"' + e.trim() + '\"]'\n\t    })\n\t    return list\n\t  }\n\t\n\t  function selectAllTags() {\n\t    var keys = Object.keys(tagImpl)\n\t    return keys + addRiotTags(keys)\n\t  }\n\t\n\t  function pushTags(root) {\n\t    var last\n\t    if (root.tagName) {\n\t      if (tagName && (!(last = root.getAttribute(RIOT_TAG)) || last != tagName))\n\t        root.setAttribute(RIOT_TAG, tagName)\n\t\n\t      var tag = mountTo(root,\n\t        tagName || root.getAttribute(RIOT_TAG) || root.tagName.toLowerCase(), opts)\n\t\n\t      if (tag) tags.push(tag)\n\t    }\n\t    else if (root.length) {\n\t      each(root, pushTags)   // assume nodeList\n\t    }\n\t  }\n\t\n\t  // ----- mount code -----\n\t\n\t  if (typeof tagName === T_OBJECT) {\n\t    opts = tagName\n\t    tagName = 0\n\t  }\n\t\n\t  // crawl the DOM to find the tag\n\t  if (typeof selector === T_STRING) {\n\t    if (selector === '*')\n\t      // select all the tags registered\n\t      // and also the tags found with the riot-tag attribute set\n\t      selector = allTags = selectAllTags()\n\t    else\n\t      // or just the ones named like the selector\n\t      selector += addRiotTags(selector.split(','))\n\t\n\t    els = $$(selector)\n\t  }\n\t  else\n\t    // probably you have passed already a tag or a NodeList\n\t    els = selector\n\t\n\t  // select all the registered and mount them inside their root elements\n\t  if (tagName === '*') {\n\t    // get all custom tags\n\t    tagName = allTags || selectAllTags()\n\t    // if the root els it's just a single tag\n\t    if (els.tagName)\n\t      els = $$(tagName, els)\n\t    else {\n\t      // select all the children for all the different root elements\n\t      var nodeList = []\n\t      each(els, function (_el) {\n\t        nodeList.push($$(tagName, _el))\n\t      })\n\t      els = nodeList\n\t    }\n\t    // get rid of the tagName\n\t    tagName = 0\n\t  }\n\t\n\t  if (els.tagName)\n\t    pushTags(els)\n\t  else\n\t    each(els, pushTags)\n\t\n\t  return tags\n\t}\n\t\n\t// update everything\n\triot.update = function() {\n\t  return each(virtualDom, function(tag) {\n\t    tag.update()\n\t  })\n\t}\n\t\n\t// @deprecated\n\triot.mountTo = riot.mount\n\t\n\t  // share methods for other riot parts, e.g. compiler\n\t  riot.util = { brackets: brackets, tmpl: tmpl }\n\t\n\t  // support CommonJS, AMD & browser\n\t  /* istanbul ignore next */\n\t  if (typeof exports === T_OBJECT)\n\t    module.exports = riot\n\t  else if (true)\n\t    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() { return (window.riot = riot) }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\t  else\n\t    window.riot = riot\n\t\n\t})(typeof window != 'undefined' ? window : void 0);\n\n\n/***/ },\n/* 2 */\n/*!************************************!*\\\n  !*** ./~/superagent/lib/client.js ***!\n  \\************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Module dependencies.\n\t */\n\t\n\tvar Emitter = __webpack_require__(/*! emitter */ 4);\n\tvar reduce = __webpack_require__(/*! reduce */ 5);\n\t\n\t/**\n\t * Root reference for iframes.\n\t */\n\t\n\tvar root;\n\tif (typeof window !== 'undefined') { // Browser window\n\t  root = window;\n\t} else if (typeof self !== 'undefined') { // Web Worker\n\t  root = self;\n\t} else { // Other environments\n\t  root = this;\n\t}\n\t\n\t/**\n\t * Noop.\n\t */\n\t\n\tfunction noop(){};\n\t\n\t/**\n\t * Check if `obj` is a host object,\n\t * we don't want to serialize these :)\n\t *\n\t * TODO: future proof, move to compoent land\n\t *\n\t * @param {Object} obj\n\t * @return {Boolean}\n\t * @api private\n\t */\n\t\n\tfunction isHost(obj) {\n\t  var str = {}.toString.call(obj);\n\t\n\t  switch (str) {\n\t    case '[object File]':\n\t    case '[object Blob]':\n\t    case '[object FormData]':\n\t      return true;\n\t    default:\n\t      return false;\n\t  }\n\t}\n\t\n\t/**\n\t * Determine XHR.\n\t */\n\t\n\trequest.getXHR = function () {\n\t  if (root.XMLHttpRequest\n\t      && (!root.location || 'file:' != root.location.protocol\n\t          || !root.ActiveXObject)) {\n\t    return new XMLHttpRequest;\n\t  } else {\n\t    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n\t    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n\t    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n\t    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n\t  }\n\t  return false;\n\t};\n\t\n\t/**\n\t * Removes leading and trailing whitespace, added to support IE.\n\t *\n\t * @param {String} s\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tvar trim = ''.trim\n\t  ? function(s) { return s.trim(); }\n\t  : function(s) { return s.replace(/(^\\s*|\\s*$)/g, ''); };\n\t\n\t/**\n\t * Check if `obj` is an object.\n\t *\n\t * @param {Object} obj\n\t * @return {Boolean}\n\t * @api private\n\t */\n\t\n\tfunction isObject(obj) {\n\t  return obj === Object(obj);\n\t}\n\t\n\t/**\n\t * Serialize the given `obj`.\n\t *\n\t * @param {Object} obj\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction serialize(obj) {\n\t  if (!isObject(obj)) return obj;\n\t  var pairs = [];\n\t  for (var key in obj) {\n\t    if (null != obj[key]) {\n\t      pairs.push(encodeURIComponent(key)\n\t        + '=' + encodeURIComponent(obj[key]));\n\t    }\n\t  }\n\t  return pairs.join('&');\n\t}\n\t\n\t/**\n\t * Expose serialization method.\n\t */\n\t\n\t request.serializeObject = serialize;\n\t\n\t /**\n\t  * Parse the given x-www-form-urlencoded `str`.\n\t  *\n\t  * @param {String} str\n\t  * @return {Object}\n\t  * @api private\n\t  */\n\t\n\tfunction parseString(str) {\n\t  var obj = {};\n\t  var pairs = str.split('&');\n\t  var parts;\n\t  var pair;\n\t\n\t  for (var i = 0, len = pairs.length; i < len; ++i) {\n\t    pair = pairs[i];\n\t    parts = pair.split('=');\n\t    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);\n\t  }\n\t\n\t  return obj;\n\t}\n\t\n\t/**\n\t * Expose parser.\n\t */\n\t\n\trequest.parseString = parseString;\n\t\n\t/**\n\t * Default MIME type map.\n\t *\n\t *     superagent.types.xml = 'application/xml';\n\t *\n\t */\n\t\n\trequest.types = {\n\t  html: 'text/html',\n\t  json: 'application/json',\n\t  xml: 'application/xml',\n\t  urlencoded: 'application/x-www-form-urlencoded',\n\t  'form': 'application/x-www-form-urlencoded',\n\t  'form-data': 'application/x-www-form-urlencoded'\n\t};\n\t\n\t/**\n\t * Default serialization map.\n\t *\n\t *     superagent.serialize['application/xml'] = function(obj){\n\t *       return 'generated xml here';\n\t *     };\n\t *\n\t */\n\t\n\t request.serialize = {\n\t   'application/x-www-form-urlencoded': serialize,\n\t   'application/json': JSON.stringify\n\t };\n\t\n\t /**\n\t  * Default parsers.\n\t  *\n\t  *     superagent.parse['application/xml'] = function(str){\n\t  *       return { object parsed from str };\n\t  *     };\n\t  *\n\t  */\n\t\n\trequest.parse = {\n\t  'application/x-www-form-urlencoded': parseString,\n\t  'application/json': JSON.parse\n\t};\n\t\n\t/**\n\t * Parse the given header `str` into\n\t * an object containing the mapped fields.\n\t *\n\t * @param {String} str\n\t * @return {Object}\n\t * @api private\n\t */\n\t\n\tfunction parseHeader(str) {\n\t  var lines = str.split(/\\r?\\n/);\n\t  var fields = {};\n\t  var index;\n\t  var line;\n\t  var field;\n\t  var val;\n\t\n\t  lines.pop(); // trailing CRLF\n\t\n\t  for (var i = 0, len = lines.length; i < len; ++i) {\n\t    line = lines[i];\n\t    index = line.indexOf(':');\n\t    field = line.slice(0, index).toLowerCase();\n\t    val = trim(line.slice(index + 1));\n\t    fields[field] = val;\n\t  }\n\t\n\t  return fields;\n\t}\n\t\n\t/**\n\t * Return the mime type for the given `str`.\n\t *\n\t * @param {String} str\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction type(str){\n\t  return str.split(/ *; */).shift();\n\t};\n\t\n\t/**\n\t * Return header field parameters.\n\t *\n\t * @param {String} str\n\t * @return {Object}\n\t * @api private\n\t */\n\t\n\tfunction params(str){\n\t  return reduce(str.split(/ *; */), function(obj, str){\n\t    var parts = str.split(/ *= */)\n\t      , key = parts.shift()\n\t      , val = parts.shift();\n\t\n\t    if (key && val) obj[key] = val;\n\t    return obj;\n\t  }, {});\n\t};\n\t\n\t/**\n\t * Initialize a new `Response` with the given `xhr`.\n\t *\n\t *  - set flags (.ok, .error, etc)\n\t *  - parse header\n\t *\n\t * Examples:\n\t *\n\t *  Aliasing `superagent` as `request` is nice:\n\t *\n\t *      request = superagent;\n\t *\n\t *  We can use the promise-like API, or pass callbacks:\n\t *\n\t *      request.get('/').end(function(res){});\n\t *      request.get('/', function(res){});\n\t *\n\t *  Sending data can be chained:\n\t *\n\t *      request\n\t *        .post('/user')\n\t *        .send({ name: 'tj' })\n\t *        .end(function(res){});\n\t *\n\t *  Or passed to `.send()`:\n\t *\n\t *      request\n\t *        .post('/user')\n\t *        .send({ name: 'tj' }, function(res){});\n\t *\n\t *  Or passed to `.post()`:\n\t *\n\t *      request\n\t *        .post('/user', { name: 'tj' })\n\t *        .end(function(res){});\n\t *\n\t * Or further reduced to a single call for simple cases:\n\t *\n\t *      request\n\t *        .post('/user', { name: 'tj' }, function(res){});\n\t *\n\t * @param {XMLHTTPRequest} xhr\n\t * @param {Object} options\n\t * @api private\n\t */\n\t\n\tfunction Response(req, options) {\n\t  options = options || {};\n\t  this.req = req;\n\t  this.xhr = this.req.xhr;\n\t  // responseText is accessible only if responseType is '' or 'text' and on older browsers\n\t  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')\n\t     ? this.xhr.responseText\n\t     : null;\n\t  this.statusText = this.req.xhr.statusText;\n\t  this.setStatusProperties(this.xhr.status);\n\t  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());\n\t  // getAllResponseHeaders sometimes falsely returns \"\" for CORS requests, but\n\t  // getResponseHeader still works. so we get content-type even if getting\n\t  // other headers fails.\n\t  this.header['content-type'] = this.xhr.getResponseHeader('content-type');\n\t  this.setHeaderProperties(this.header);\n\t  this.body = this.req.method != 'HEAD'\n\t    ? this.parseBody(this.text ? this.text : this.xhr.response)\n\t    : null;\n\t}\n\t\n\t/**\n\t * Get case-insensitive `field` value.\n\t *\n\t * @param {String} field\n\t * @return {String}\n\t * @api public\n\t */\n\t\n\tResponse.prototype.get = function(field){\n\t  return this.header[field.toLowerCase()];\n\t};\n\t\n\t/**\n\t * Set header related properties:\n\t *\n\t *   - `.type` the content type without params\n\t *\n\t * A response of \"Content-Type: text/plain; charset=utf-8\"\n\t * will provide you with a `.type` of \"text/plain\".\n\t *\n\t * @param {Object} header\n\t * @api private\n\t */\n\t\n\tResponse.prototype.setHeaderProperties = function(header){\n\t  // content-type\n\t  var ct = this.header['content-type'] || '';\n\t  this.type = type(ct);\n\t\n\t  // params\n\t  var obj = params(ct);\n\t  for (var key in obj) this[key] = obj[key];\n\t};\n\t\n\t/**\n\t * Force given parser\n\t * \n\t * Sets the body parser no matter type.\n\t * \n\t * @param {Function}\n\t * @api public\n\t */\n\t\n\tResponse.prototype.parse = function(fn){\n\t  this.parser = fn;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Parse the given body `str`.\n\t *\n\t * Used for auto-parsing of bodies. Parsers\n\t * are defined on the `superagent.parse` object.\n\t *\n\t * @param {String} str\n\t * @return {Mixed}\n\t * @api private\n\t */\n\t\n\tResponse.prototype.parseBody = function(str){\n\t  var parse = this.parser || request.parse[this.type];\n\t  return parse && str && (str.length || str instanceof Object)\n\t    ? parse(str)\n\t    : null;\n\t};\n\t\n\t/**\n\t * Set flags such as `.ok` based on `status`.\n\t *\n\t * For example a 2xx response will give you a `.ok` of __true__\n\t * whereas 5xx will be __false__ and `.error` will be __true__. The\n\t * `.clientError` and `.serverError` are also available to be more\n\t * specific, and `.statusType` is the class of error ranging from 1..5\n\t * sometimes useful for mapping respond colors etc.\n\t *\n\t * \"sugar\" properties are also defined for common cases. Currently providing:\n\t *\n\t *   - .noContent\n\t *   - .badRequest\n\t *   - .unauthorized\n\t *   - .notAcceptable\n\t *   - .notFound\n\t *\n\t * @param {Number} status\n\t * @api private\n\t */\n\t\n\tResponse.prototype.setStatusProperties = function(status){\n\t  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n\t  if (status === 1223) {\n\t    status = 204;\n\t  }\n\t\n\t  var type = status / 100 | 0;\n\t\n\t  // status / class\n\t  this.status = this.statusCode = status;\n\t  this.statusType = type;\n\t\n\t  // basics\n\t  this.info = 1 == type;\n\t  this.ok = 2 == type;\n\t  this.clientError = 4 == type;\n\t  this.serverError = 5 == type;\n\t  this.error = (4 == type || 5 == type)\n\t    ? this.toError()\n\t    : false;\n\t\n\t  // sugar\n\t  this.accepted = 202 == status;\n\t  this.noContent = 204 == status;\n\t  this.badRequest = 400 == status;\n\t  this.unauthorized = 401 == status;\n\t  this.notAcceptable = 406 == status;\n\t  this.notFound = 404 == status;\n\t  this.forbidden = 403 == status;\n\t};\n\t\n\t/**\n\t * Return an `Error` representative of this response.\n\t *\n\t * @return {Error}\n\t * @api public\n\t */\n\t\n\tResponse.prototype.toError = function(){\n\t  var req = this.req;\n\t  var method = req.method;\n\t  var url = req.url;\n\t\n\t  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';\n\t  var err = new Error(msg);\n\t  err.status = this.status;\n\t  err.method = method;\n\t  err.url = url;\n\t\n\t  return err;\n\t};\n\t\n\t/**\n\t * Expose `Response`.\n\t */\n\t\n\trequest.Response = Response;\n\t\n\t/**\n\t * Initialize a new `Request` with the given `method` and `url`.\n\t *\n\t * @param {String} method\n\t * @param {String} url\n\t * @api public\n\t */\n\t\n\tfunction Request(method, url) {\n\t  var self = this;\n\t  Emitter.call(this);\n\t  this._query = this._query || [];\n\t  this.method = method;\n\t  this.url = url;\n\t  this.header = {};\n\t  this._header = {};\n\t  this.on('end', function(){\n\t    var err = null;\n\t    var res = null;\n\t\n\t    try {\n\t      res = new Response(self);\n\t    } catch(e) {\n\t      err = new Error('Parser is unable to parse the response');\n\t      err.parse = true;\n\t      err.original = e;\n\t      return self.callback(err);\n\t    }\n\t\n\t    self.emit('response', res);\n\t\n\t    if (err) {\n\t      return self.callback(err, res);\n\t    }\n\t\n\t    if (res.status >= 200 && res.status < 300) {\n\t      return self.callback(err, res);\n\t    }\n\t\n\t    var new_err = new Error(res.statusText || 'Unsuccessful HTTP response');\n\t    new_err.original = err;\n\t    new_err.response = res;\n\t    new_err.status = res.status;\n\t\n\t    self.callback(new_err, res);\n\t  });\n\t}\n\t\n\t/**\n\t * Mixin `Emitter`.\n\t */\n\t\n\tEmitter(Request.prototype);\n\t\n\t/**\n\t * Allow for extension\n\t */\n\t\n\tRequest.prototype.use = function(fn) {\n\t  fn(this);\n\t  return this;\n\t}\n\t\n\t/**\n\t * Set timeout to `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.timeout = function(ms){\n\t  this._timeout = ms;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Clear previous timeout.\n\t *\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.clearTimeout = function(){\n\t  this._timeout = 0;\n\t  clearTimeout(this._timer);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Abort the request, and clear potential timeout.\n\t *\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\tRequest.prototype.abort = function(){\n\t  if (this.aborted) return;\n\t  this.aborted = true;\n\t  this.xhr.abort();\n\t  this.clearTimeout();\n\t  this.emit('abort');\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set header `field` to `val`, or multiple fields with one object.\n\t *\n\t * Examples:\n\t *\n\t *      req.get('/')\n\t *        .set('Accept', 'application/json')\n\t *        .set('X-API-Key', 'foobar')\n\t *        .end(callback);\n\t *\n\t *      req.get('/')\n\t *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })\n\t *        .end(callback);\n\t *\n\t * @param {String|Object} field\n\t * @param {String} val\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.set = function(field, val){\n\t  if (isObject(field)) {\n\t    for (var key in field) {\n\t      this.set(key, field[key]);\n\t    }\n\t    return this;\n\t  }\n\t  this._header[field.toLowerCase()] = val;\n\t  this.header[field] = val;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove header `field`.\n\t *\n\t * Example:\n\t *\n\t *      req.get('/')\n\t *        .unset('User-Agent')\n\t *        .end(callback);\n\t *\n\t * @param {String} field\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.unset = function(field){\n\t  delete this._header[field.toLowerCase()];\n\t  delete this.header[field];\n\t  return this;\n\t};\n\t\n\t/**\n\t * Get case-insensitive header `field` value.\n\t *\n\t * @param {String} field\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tRequest.prototype.getHeader = function(field){\n\t  return this._header[field.toLowerCase()];\n\t};\n\t\n\t/**\n\t * Set Content-Type to `type`, mapping values from `request.types`.\n\t *\n\t * Examples:\n\t *\n\t *      superagent.types.xml = 'application/xml';\n\t *\n\t *      request.post('/')\n\t *        .type('xml')\n\t *        .send(xmlstring)\n\t *        .end(callback);\n\t *\n\t *      request.post('/')\n\t *        .type('application/xml')\n\t *        .send(xmlstring)\n\t *        .end(callback);\n\t *\n\t * @param {String} type\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.type = function(type){\n\t  this.set('Content-Type', request.types[type] || type);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set Accept to `type`, mapping values from `request.types`.\n\t *\n\t * Examples:\n\t *\n\t *      superagent.types.json = 'application/json';\n\t *\n\t *      request.get('/agent')\n\t *        .accept('json')\n\t *        .end(callback);\n\t *\n\t *      request.get('/agent')\n\t *        .accept('application/json')\n\t *        .end(callback);\n\t *\n\t * @param {String} accept\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.accept = function(type){\n\t  this.set('Accept', request.types[type] || type);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set Authorization field value with `user` and `pass`.\n\t *\n\t * @param {String} user\n\t * @param {String} pass\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.auth = function(user, pass){\n\t  var str = btoa(user + ':' + pass);\n\t  this.set('Authorization', 'Basic ' + str);\n\t  return this;\n\t};\n\t\n\t/**\n\t* Add query-string `val`.\n\t*\n\t* Examples:\n\t*\n\t*   request.get('/shoes')\n\t*     .query('size=10')\n\t*     .query({ color: 'blue' })\n\t*\n\t* @param {Object|String} val\n\t* @return {Request} for chaining\n\t* @api public\n\t*/\n\t\n\tRequest.prototype.query = function(val){\n\t  if ('string' != typeof val) val = serialize(val);\n\t  if (val) this._query.push(val);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Write the field `name` and `val` for \"multipart/form-data\"\n\t * request bodies.\n\t *\n\t * ``` js\n\t * request.post('/upload')\n\t *   .field('foo', 'bar')\n\t *   .end(callback);\n\t * ```\n\t *\n\t * @param {String} name\n\t * @param {String|Blob|File} val\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.field = function(name, val){\n\t  if (!this._formData) this._formData = new root.FormData();\n\t  this._formData.append(name, val);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Queue the given `file` as an attachment to the specified `field`,\n\t * with optional `filename`.\n\t *\n\t * ``` js\n\t * request.post('/upload')\n\t *   .attach(new Blob(['<a id=\"a\"><b id=\"b\">hey!</b></a>'], { type: \"text/html\"}))\n\t *   .end(callback);\n\t * ```\n\t *\n\t * @param {String} field\n\t * @param {Blob|File} file\n\t * @param {String} filename\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.attach = function(field, file, filename){\n\t  if (!this._formData) this._formData = new root.FormData();\n\t  this._formData.append(field, file, filename);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Send `data`, defaulting the `.type()` to \"json\" when\n\t * an object is given.\n\t *\n\t * Examples:\n\t *\n\t *       // querystring\n\t *       request.get('/search')\n\t *         .end(callback)\n\t *\n\t *       // multiple data \"writes\"\n\t *       request.get('/search')\n\t *         .send({ search: 'query' })\n\t *         .send({ range: '1..5' })\n\t *         .send({ order: 'desc' })\n\t *         .end(callback)\n\t *\n\t *       // manual json\n\t *       request.post('/user')\n\t *         .type('json')\n\t *         .send('{\"name\":\"tj\"})\n\t *         .end(callback)\n\t *\n\t *       // auto json\n\t *       request.post('/user')\n\t *         .send({ name: 'tj' })\n\t *         .end(callback)\n\t *\n\t *       // manual x-www-form-urlencoded\n\t *       request.post('/user')\n\t *         .type('form')\n\t *         .send('name=tj')\n\t *         .end(callback)\n\t *\n\t *       // auto x-www-form-urlencoded\n\t *       request.post('/user')\n\t *         .type('form')\n\t *         .send({ name: 'tj' })\n\t *         .end(callback)\n\t *\n\t *       // defaults to x-www-form-urlencoded\n\t  *      request.post('/user')\n\t  *        .send('name=tobi')\n\t  *        .send('species=ferret')\n\t  *        .end(callback)\n\t *\n\t * @param {String|Object} data\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.send = function(data){\n\t  var obj = isObject(data);\n\t  var type = this.getHeader('Content-Type');\n\t\n\t  // merge\n\t  if (obj && isObject(this._data)) {\n\t    for (var key in data) {\n\t      this._data[key] = data[key];\n\t    }\n\t  } else if ('string' == typeof data) {\n\t    if (!type) this.type('form');\n\t    type = this.getHeader('Content-Type');\n\t    if ('application/x-www-form-urlencoded' == type) {\n\t      this._data = this._data\n\t        ? this._data + '&' + data\n\t        : data;\n\t    } else {\n\t      this._data = (this._data || '') + data;\n\t    }\n\t  } else {\n\t    this._data = data;\n\t  }\n\t\n\t  if (!obj || isHost(data)) return this;\n\t  if (!type) this.type('json');\n\t  return this;\n\t};\n\t\n\t/**\n\t * Invoke the callback with `err` and `res`\n\t * and handle arity check.\n\t *\n\t * @param {Error} err\n\t * @param {Response} res\n\t * @api private\n\t */\n\t\n\tRequest.prototype.callback = function(err, res){\n\t  var fn = this._callback;\n\t  this.clearTimeout();\n\t  fn(err, res);\n\t};\n\t\n\t/**\n\t * Invoke callback with x-domain error.\n\t *\n\t * @api private\n\t */\n\t\n\tRequest.prototype.crossDomainError = function(){\n\t  var err = new Error('Origin is not allowed by Access-Control-Allow-Origin');\n\t  err.crossDomain = true;\n\t  this.callback(err);\n\t};\n\t\n\t/**\n\t * Invoke callback with timeout error.\n\t *\n\t * @api private\n\t */\n\t\n\tRequest.prototype.timeoutError = function(){\n\t  var timeout = this._timeout;\n\t  var err = new Error('timeout of ' + timeout + 'ms exceeded');\n\t  err.timeout = timeout;\n\t  this.callback(err);\n\t};\n\t\n\t/**\n\t * Enable transmission of cookies with x-domain requests.\n\t *\n\t * Note that for this to work the origin must not be\n\t * using \"Access-Control-Allow-Origin\" with a wildcard,\n\t * and also must set \"Access-Control-Allow-Credentials\"\n\t * to \"true\".\n\t *\n\t * @api public\n\t */\n\t\n\tRequest.prototype.withCredentials = function(){\n\t  this._withCredentials = true;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Initiate request, invoking callback `fn(res)`\n\t * with an instanceof `Response`.\n\t *\n\t * @param {Function} fn\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.end = function(fn){\n\t  var self = this;\n\t  var xhr = this.xhr = request.getXHR();\n\t  var query = this._query.join('&');\n\t  var timeout = this._timeout;\n\t  var data = this._formData || this._data;\n\t\n\t  // store callback\n\t  this._callback = fn || noop;\n\t\n\t  // state change\n\t  xhr.onreadystatechange = function(){\n\t    if (4 != xhr.readyState) return;\n\t\n\t    // In IE9, reads to any property (e.g. status) off of an aborted XHR will\n\t    // result in the error \"Could not complete the operation due to error c00c023f\"\n\t    var status;\n\t    try { status = xhr.status } catch(e) { status = 0; }\n\t\n\t    if (0 == status) {\n\t      if (self.timedout) return self.timeoutError();\n\t      if (self.aborted) return;\n\t      return self.crossDomainError();\n\t    }\n\t    self.emit('end');\n\t  };\n\t\n\t  // progress\n\t  var handleProgress = function(e){\n\t    if (e.total > 0) {\n\t      e.percent = e.loaded / e.total * 100;\n\t    }\n\t    self.emit('progress', e);\n\t  };\n\t  if (this.hasListeners('progress')) {\n\t    xhr.onprogress = handleProgress;\n\t  }\n\t  try {\n\t    if (xhr.upload && this.hasListeners('progress')) {\n\t      xhr.upload.onprogress = handleProgress;\n\t    }\n\t  } catch(e) {\n\t    // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.\n\t    // Reported here:\n\t    // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context\n\t  }\n\t\n\t  // timeout\n\t  if (timeout && !this._timer) {\n\t    this._timer = setTimeout(function(){\n\t      self.timedout = true;\n\t      self.abort();\n\t    }, timeout);\n\t  }\n\t\n\t  // querystring\n\t  if (query) {\n\t    query = request.serializeObject(query);\n\t    this.url += ~this.url.indexOf('?')\n\t      ? '&' + query\n\t      : '?' + query;\n\t  }\n\t\n\t  // initiate request\n\t  xhr.open(this.method, this.url, true);\n\t\n\t  // CORS\n\t  if (this._withCredentials) xhr.withCredentials = true;\n\t\n\t  // body\n\t  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {\n\t    // serialize stuff\n\t    var contentType = this.getHeader('Content-Type');\n\t    var serialize = request.serialize[contentType ? contentType.split(';')[0] : ''];\n\t    if (serialize) data = serialize(data);\n\t  }\n\t\n\t  // set header fields\n\t  for (var field in this.header) {\n\t    if (null == this.header[field]) continue;\n\t    xhr.setRequestHeader(field, this.header[field]);\n\t  }\n\t\n\t  // send stuff\n\t  this.emit('request', this);\n\t  xhr.send(data);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Faux promise support\n\t *\n\t * @param {Function} fulfill\n\t * @param {Function} reject\n\t * @return {Request}\n\t */\n\t\n\tRequest.prototype.then = function (fulfill, reject) {\n\t  return this.end(function(err, res) {\n\t    err ? reject(err) : fulfill(res);\n\t  });\n\t}\n\t\n\t/**\n\t * Expose `Request`.\n\t */\n\t\n\trequest.Request = Request;\n\t\n\t/**\n\t * Issue a request:\n\t *\n\t * Examples:\n\t *\n\t *    request('GET', '/users').end(callback)\n\t *    request('/users').end(callback)\n\t *    request('/users', callback)\n\t *\n\t * @param {String} method\n\t * @param {String|Function} url or callback\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\tfunction request(method, url) {\n\t  // callback\n\t  if ('function' == typeof url) {\n\t    return new Request('GET', method).end(url);\n\t  }\n\t\n\t  // url first\n\t  if (1 == arguments.length) {\n\t    return new Request('GET', method);\n\t  }\n\t\n\t  return new Request(method, url);\n\t}\n\t\n\t/**\n\t * GET `url` with optional callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Mixed|Function} data or fn\n\t * @param {Function} fn\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\trequest.get = function(url, data, fn){\n\t  var req = request('GET', url);\n\t  if ('function' == typeof data) fn = data, data = null;\n\t  if (data) req.query(data);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\t\n\t/**\n\t * HEAD `url` with optional callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Mixed|Function} data or fn\n\t * @param {Function} fn\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\trequest.head = function(url, data, fn){\n\t  var req = request('HEAD', url);\n\t  if ('function' == typeof data) fn = data, data = null;\n\t  if (data) req.send(data);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\t\n\t/**\n\t * DELETE `url` with optional callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Function} fn\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\trequest.del = function(url, fn){\n\t  var req = request('DELETE', url);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\t\n\t/**\n\t * PATCH `url` with optional `data` and callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Mixed} data\n\t * @param {Function} fn\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\trequest.patch = function(url, data, fn){\n\t  var req = request('PATCH', url);\n\t  if ('function' == typeof data) fn = data, data = null;\n\t  if (data) req.send(data);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\t\n\t/**\n\t * POST `url` with optional `data` and callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Mixed} data\n\t * @param {Function} fn\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\trequest.post = function(url, data, fn){\n\t  var req = request('POST', url);\n\t  if ('function' == typeof data) fn = data, data = null;\n\t  if (data) req.send(data);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\t\n\t/**\n\t * PUT `url` with optional `data` and callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Mixed|Function} data or fn\n\t * @param {Function} fn\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\trequest.put = function(url, data, fn){\n\t  var req = request('PUT', url);\n\t  if ('function' == typeof data) fn = data, data = null;\n\t  if (data) req.send(data);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\t\n\t/**\n\t * Expose `request`.\n\t */\n\t\n\tmodule.exports = request;\n\n\n/***/ },\n/* 3 */,\n/* 4 */\n/*!***************************************************!*\\\n  !*** ./~/superagent/~/component-emitter/index.js ***!\n  \\***************************************************/\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * Expose `Emitter`.\n\t */\n\t\n\tmodule.exports = Emitter;\n\t\n\t/**\n\t * Initialize a new `Emitter`.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction Emitter(obj) {\n\t  if (obj) return mixin(obj);\n\t};\n\t\n\t/**\n\t * Mixin the emitter properties.\n\t *\n\t * @param {Object} obj\n\t * @return {Object}\n\t * @api private\n\t */\n\t\n\tfunction mixin(obj) {\n\t  for (var key in Emitter.prototype) {\n\t    obj[key] = Emitter.prototype[key];\n\t  }\n\t  return obj;\n\t}\n\t\n\t/**\n\t * Listen on the given `event` with `fn`.\n\t *\n\t * @param {String} event\n\t * @param {Function} fn\n\t * @return {Emitter}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.on =\n\tEmitter.prototype.addEventListener = function(event, fn){\n\t  this._callbacks = this._callbacks || {};\n\t  (this._callbacks[event] = this._callbacks[event] || [])\n\t    .push(fn);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Adds an `event` listener that will be invoked a single\n\t * time then automatically removed.\n\t *\n\t * @param {String} event\n\t * @param {Function} fn\n\t * @return {Emitter}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.once = function(event, fn){\n\t  var self = this;\n\t  this._callbacks = this._callbacks || {};\n\t\n\t  function on() {\n\t    self.off(event, on);\n\t    fn.apply(this, arguments);\n\t  }\n\t\n\t  on.fn = fn;\n\t  this.on(event, on);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove the given callback for `event` or all\n\t * registered callbacks.\n\t *\n\t * @param {String} event\n\t * @param {Function} fn\n\t * @return {Emitter}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.off =\n\tEmitter.prototype.removeListener =\n\tEmitter.prototype.removeAllListeners =\n\tEmitter.prototype.removeEventListener = function(event, fn){\n\t  this._callbacks = this._callbacks || {};\n\t\n\t  // all\n\t  if (0 == arguments.length) {\n\t    this._callbacks = {};\n\t    return this;\n\t  }\n\t\n\t  // specific event\n\t  var callbacks = this._callbacks[event];\n\t  if (!callbacks) return this;\n\t\n\t  // remove all handlers\n\t  if (1 == arguments.length) {\n\t    delete this._callbacks[event];\n\t    return this;\n\t  }\n\t\n\t  // remove specific handler\n\t  var cb;\n\t  for (var i = 0; i < callbacks.length; i++) {\n\t    cb = callbacks[i];\n\t    if (cb === fn || cb.fn === fn) {\n\t      callbacks.splice(i, 1);\n\t      break;\n\t    }\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Emit `event` with the given args.\n\t *\n\t * @param {String} event\n\t * @param {Mixed} ...\n\t * @return {Emitter}\n\t */\n\t\n\tEmitter.prototype.emit = function(event){\n\t  this._callbacks = this._callbacks || {};\n\t  var args = [].slice.call(arguments, 1)\n\t    , callbacks = this._callbacks[event];\n\t\n\t  if (callbacks) {\n\t    callbacks = callbacks.slice(0);\n\t    for (var i = 0, len = callbacks.length; i < len; ++i) {\n\t      callbacks[i].apply(this, args);\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Return array of callbacks for `event`.\n\t *\n\t * @param {String} event\n\t * @return {Array}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.listeners = function(event){\n\t  this._callbacks = this._callbacks || {};\n\t  return this._callbacks[event] || [];\n\t};\n\t\n\t/**\n\t * Check if this emitter has `event` handlers.\n\t *\n\t * @param {String} event\n\t * @return {Boolean}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.hasListeners = function(event){\n\t  return !! this.listeners(event).length;\n\t};\n\n\n/***/ },\n/* 5 */\n/*!**************************************************!*\\\n  !*** ./~/superagent/~/reduce-component/index.js ***!\n  \\**************************************************/\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * Reduce `arr` with `fn`.\n\t *\n\t * @param {Array} arr\n\t * @param {Function} fn\n\t * @param {Mixed} initial\n\t *\n\t * TODO: combatible error handling?\n\t */\n\t\n\tmodule.exports = function(arr, fn, initial){  \n\t  var idx = 0;\n\t  var len = arr.length;\n\t  var curr = arguments.length == 3\n\t    ? initial\n\t    : arr[idx++];\n\t\n\t  while (idx < len) {\n\t    curr = fn.call(null, curr, arr[idx], ++idx, arr);\n\t  }\n\t  \n\t  return curr;\n\t};\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** vendor.bundle.js\n **/"," \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId])\n \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n \t\twhile(callbacks.length)\n \t\t\tcallbacks.shift().call(null, __webpack_require__);\n \t\tif(moreModules[0]) {\n \t\t\tinstalledModules[0] = 0;\n \t\t\treturn __webpack_require__(0);\n \t\t}\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// \"0\" means \"already loaded\"\n \t// Array means \"loading\", array contains callbacks\n \tvar installedChunks = {\n \t\t0:0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n \t\t// \"0\" is the signal for \"already loaded\"\n \t\tif(installedChunks[chunkId] === 0)\n \t\t\treturn callback.call(null, __webpack_require__);\n\n \t\t// an array means \"currently loading\".\n \t\tif(installedChunks[chunkId] !== undefined) {\n \t\t\tinstalledChunks[chunkId].push(callback);\n \t\t} else {\n \t\t\t// start chunk loading\n \t\t\tinstalledChunks[chunkId] = [callback];\n \t\t\tvar head = document.getElementsByTagName('head')[0];\n \t\t\tvar script = document.createElement('script');\n \t\t\tscript.type = 'text/javascript';\n \t\t\tscript.charset = 'utf-8';\n \t\t\tscript.async = true;\n\n \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".bundle.js\";\n \t\t\thead.appendChild(script);\n \t\t}\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 5cc4b7120383228bb2b6\n **/","import 'riot'\nimport 'superagent/lib/client'\n\n\n\n/** WEBPACK FOOTER **\n ** ./static/src/vendor.es6\n **/","/* Riot v2.2.4, @license MIT, (c) 2015 Muut Inc. + contributors */\n\n;(function(window, undefined) {\n  'use strict';\nvar riot = { version: 'v2.2.4', settings: {} },\n  //// be aware, internal usage\n\n  // counter to give a unique id to all the Tag instances\n  __uid = 0,\n\n  // riot specific prefixes\n  RIOT_PREFIX = 'riot-',\n  RIOT_TAG = RIOT_PREFIX + 'tag',\n\n  // for typeof == '' comparisons\n  T_STRING = 'string',\n  T_OBJECT = 'object',\n  T_UNDEF  = 'undefined',\n  T_FUNCTION = 'function',\n  // special native tags that cannot be treated like the others\n  SPECIAL_TAGS_REGEX = /^(?:opt(ion|group)|tbody|col|t[rhd])$/,\n  RESERVED_WORDS_BLACKLIST = ['_item', '_id', 'update', 'root', 'mount', 'unmount', 'mixin', 'isMounted', 'isLoop', 'tags', 'parent', 'opts', 'trigger', 'on', 'off', 'one'],\n\n  // version# for IE 8-11, 0 for others\n  IE_VERSION = (window && window.document || {}).documentMode | 0,\n\n  // Array.isArray for IE8 is in the polyfills\n  isArray = Array.isArray\n\nriot.observable = function(el) {\n\n  el = el || {}\n\n  var callbacks = {},\n      _id = 0\n\n  el.on = function(events, fn) {\n    if (isFunction(fn)) {\n      if (typeof fn.id === T_UNDEF) fn._id = _id++\n\n      events.replace(/\\S+/g, function(name, pos) {\n        (callbacks[name] = callbacks[name] || []).push(fn)\n        fn.typed = pos > 0\n      })\n    }\n    return el\n  }\n\n  el.off = function(events, fn) {\n    if (events == '*') callbacks = {}\n    else {\n      events.replace(/\\S+/g, function(name) {\n        if (fn) {\n          var arr = callbacks[name]\n          for (var i = 0, cb; (cb = arr && arr[i]); ++i) {\n            if (cb._id == fn._id) arr.splice(i--, 1)\n          }\n        } else {\n          callbacks[name] = []\n        }\n      })\n    }\n    return el\n  }\n\n  // only single event supported\n  el.one = function(name, fn) {\n    function on() {\n      el.off(name, on)\n      fn.apply(el, arguments)\n    }\n    return el.on(name, on)\n  }\n\n  el.trigger = function(name) {\n    var args = [].slice.call(arguments, 1),\n        fns = callbacks[name] || []\n\n    for (var i = 0, fn; (fn = fns[i]); ++i) {\n      if (!fn.busy) {\n        fn.busy = 1\n        fn.apply(el, fn.typed ? [name].concat(args) : args)\n        if (fns[i] !== fn) { i-- }\n        fn.busy = 0\n      }\n    }\n\n    if (callbacks.all && name != 'all') {\n      el.trigger.apply(el, ['all', name].concat(args))\n    }\n\n    return el\n  }\n\n  return el\n\n}\nriot.mixin = (function() {\n  var mixins = {}\n\n  return function(name, mixin) {\n    if (!mixin) return mixins[name]\n    mixins[name] = mixin\n  }\n\n})()\n\n;(function(riot, evt, win) {\n\n  // browsers only\n  if (!win) return\n\n  var loc = win.location,\n      fns = riot.observable(),\n      started = false,\n      current\n\n  function hash() {\n    return loc.href.split('#')[1] || ''   // why not loc.hash.splice(1) ?\n  }\n\n  function parser(path) {\n    return path.split('/')\n  }\n\n  function emit(path) {\n    if (path.type) path = hash()\n\n    if (path != current) {\n      fns.trigger.apply(null, ['H'].concat(parser(path)))\n      current = path\n    }\n  }\n\n  var r = riot.route = function(arg) {\n    // string\n    if (arg[0]) {\n      loc.hash = arg\n      emit(arg)\n\n    // function\n    } else {\n      fns.on('H', arg)\n    }\n  }\n\n  r.exec = function(fn) {\n    fn.apply(null, parser(hash()))\n  }\n\n  r.parser = function(fn) {\n    parser = fn\n  }\n\n  r.stop = function () {\n    if (started) {\n      if (win.removeEventListener) win.removeEventListener(evt, emit, false) //@IE8 - the if()\n      else win.detachEvent('on' + evt, emit) //@IE8\n      fns.off('*')\n      started = false\n    }\n  }\n\n  r.start = function () {\n    if (!started) {\n      if (win.addEventListener) win.addEventListener(evt, emit, false) //@IE8 - the if()\n      else win.attachEvent('on' + evt, emit) //IE8\n      started = true\n    }\n  }\n\n  // autostart the router\n  r.start()\n\n})(riot, 'hashchange', window)\n/*\n\n//// How it works?\n\n\nThree ways:\n\n1. Expressions: tmpl('{ value }', data).\n   Returns the result of evaluated expression as a raw object.\n\n2. Templates: tmpl('Hi { name } { surname }', data).\n   Returns a string with evaluated expressions.\n\n3. Filters: tmpl('{ show: !done, highlight: active }', data).\n   Returns a space separated list of trueish keys (mainly\n   used for setting html classes), e.g. \"show highlight\".\n\n\n// Template examples\n\ntmpl('{ title || \"Untitled\" }', data)\ntmpl('Results are { results ? \"ready\" : \"loading\" }', data)\ntmpl('Today is { new Date() }', data)\ntmpl('{ message.length > 140 && \"Message is too long\" }', data)\ntmpl('This item got { Math.round(rating) } stars', data)\ntmpl('<h1>{ title }</h1>{ body }', data)\n\n\n// Falsy expressions in templates\n\nIn templates (as opposed to single expressions) all falsy values\nexcept zero (undefined/null/false) will default to empty string:\n\ntmpl('{ undefined } - { false } - { null } - { 0 }', {})\n// will return: \" - - - 0\"\n\n*/\n\n\nvar brackets = (function(orig) {\n\n  var cachedBrackets,\n      r,\n      b,\n      re = /[{}]/g\n\n  return function(x) {\n\n    // make sure we use the current setting\n    var s = riot.settings.brackets || orig\n\n    // recreate cached vars if needed\n    if (cachedBrackets !== s) {\n      cachedBrackets = s\n      b = s.split(' ')\n      r = b.map(function (e) { return e.replace(/(?=.)/g, '\\\\') })\n    }\n\n    // if regexp given, rewrite it with current brackets (only if differ from default)\n    return x instanceof RegExp ? (\n        s === orig ? x :\n        new RegExp(x.source.replace(re, function(b) { return r[~~(b === '}')] }), x.global ? 'g' : '')\n      ) :\n      // else, get specific bracket\n      b[x]\n  }\n})('{ }')\n\n\nvar tmpl = (function() {\n\n  var cache = {},\n      OGLOB = '\"in d?d:' + (window ? 'window).' : 'global).'),\n      reVars =\n      /(['\"\\/])(?:[^\\\\]*?|\\\\.|.)*?\\1|\\.\\w*|\\w*:|\\b(?:(?:new|typeof|in|instanceof) |(?:this|true|false|null|undefined)\\b|function\\s*\\()|([A-Za-z_$]\\w*)/g\n\n  // build a template (or get it from cache), render with data\n  return function(str, data) {\n    return str && (cache[str] || (cache[str] = tmpl(str)))(data)\n  }\n\n\n  // create a template instance\n\n  function tmpl(s, p) {\n\n    if (s.indexOf(brackets(0)) < 0) {\n      // return raw text\n      s = s.replace(/\\n|\\r\\n?/g, '\\n')\n      return function () { return s }\n    }\n\n    // temporarily convert \\{ and \\} to a non-character\n    s = s\n      .replace(brackets(/\\\\{/g), '\\uFFF0')\n      .replace(brackets(/\\\\}/g), '\\uFFF1')\n\n    // split string to expression and non-expresion parts\n    p = split(s, extract(s, brackets(/{/), brackets(/}/)))\n\n    // is it a single expression or a template? i.e. {x} or <b>{x}</b>\n    s = (p.length === 2 && !p[0]) ?\n\n      // if expression, evaluate it\n      expr(p[1]) :\n\n      // if template, evaluate all expressions in it\n      '[' + p.map(function(s, i) {\n\n        // is it an expression or a string (every second part is an expression)\n        return i % 2 ?\n\n          // evaluate the expressions\n          expr(s, true) :\n\n          // process string parts of the template:\n          '\"' + s\n\n            // preserve new lines\n            .replace(/\\n|\\r\\n?/g, '\\\\n')\n\n            // escape quotes\n            .replace(/\"/g, '\\\\\"') +\n\n          '\"'\n\n      }).join(',') + '].join(\"\")'\n\n    return new Function('d', 'return ' + s\n      // bring escaped { and } back\n      .replace(/\\uFFF0/g, brackets(0))\n      .replace(/\\uFFF1/g, brackets(1)) + ';')\n\n  }\n\n\n  // parse { ... } expression\n\n  function expr(s, n) {\n    s = s\n\n      // convert new lines to spaces\n      .replace(/\\n|\\r\\n?/g, ' ')\n\n      // trim whitespace, brackets, strip comments\n      .replace(brackets(/^[{ ]+|[ }]+$|\\/\\*.+?\\*\\//g), '')\n\n    // is it an object literal? i.e. { key : value }\n    return /^\\s*[\\w- \"']+ *:/.test(s) ?\n\n      // if object literal, return trueish keys\n      // e.g.: { show: isOpen(), done: item.done } -> \"show done\"\n      '[' +\n\n          // extract key:val pairs, ignoring any nested objects\n          extract(s,\n\n              // name part: name:, \"name\":, 'name':, name :\n              /[\"' ]*[\\w- ]+[\"' ]*:/,\n\n              // expression part: everything upto a comma followed by a name (see above) or end of line\n              /,(?=[\"' ]*[\\w- ]+[\"' ]*:)|}|$/\n              ).map(function(pair) {\n\n                // get key, val parts\n                return pair.replace(/^[ \"']*(.+?)[ \"']*: *(.+?),? *$/, function(_, k, v) {\n\n                  // wrap all conditional parts to ignore errors\n                  return v.replace(/[^&|=!><]+/g, wrap) + '?\"' + k + '\":\"\",'\n\n                })\n\n              }).join('') +\n\n        '].join(\" \").trim()' :\n\n      // if js expression, evaluate as javascript\n      wrap(s, n)\n\n  }\n\n\n  // execute js w/o breaking on errors or undefined vars\n\n  function wrap(s, nonull) {\n    s = s.trim()\n    return !s ? '' : '(function(v){try{v=' +\n\n      // prefix vars (name => data.name)\n      s.replace(reVars, function(s, _, v) { return v ? '((\"' + v + OGLOB + v + ')' : s }) +\n\n      // default to empty string for falsy values except zero\n      '}catch(e){}return ' + (nonull === true ? '!v&&v!==0?\"\":v' : 'v') + '}).call(d)'\n  }\n\n\n  // split string by an array of substrings\n\n  function split(str, substrings) {\n    var parts = []\n    substrings.map(function(sub, i) {\n\n      // push matched expression and part before it\n      i = str.indexOf(sub)\n      parts.push(str.slice(0, i), sub)\n      str = str.slice(i + sub.length)\n    })\n    if (str) parts.push(str)\n\n    // push the remaining part\n    return parts\n  }\n\n\n  // match strings between opening and closing regexp, skipping any inner/nested matches\n\n  function extract(str, open, close) {\n\n    var start,\n        level = 0,\n        matches = [],\n        re = new RegExp('(' + open.source + ')|(' + close.source + ')', 'g')\n\n    str.replace(re, function(_, open, close, pos) {\n\n      // if outer inner bracket, mark position\n      if (!level && open) start = pos\n\n      // in(de)crease bracket level\n      level += open ? 1 : -1\n\n      // if outer closing bracket, grab the match\n      if (!level && close != null) matches.push(str.slice(start, pos + close.length))\n\n    })\n\n    return matches\n  }\n\n})()\n\n/*\n  lib/browser/tag/mkdom.js\n\n  Includes hacks needed for the Internet Explorer version 9 and bellow\n\n*/\n// http://kangax.github.io/compat-table/es5/#ie8\n// http://codeplanet.io/dropping-ie8/\n\nvar mkdom = (function (checkIE) {\n\n  var rootEls = {\n        'tr': 'tbody',\n        'th': 'tr',\n        'td': 'tr',\n        'tbody': 'table',\n        'col': 'colgroup'\n      },\n      GENERIC = 'div'\n\n  checkIE = checkIE && checkIE < 10\n\n  // creates any dom element in a div, table, or colgroup container\n  function _mkdom(html) {\n\n    var match = html && html.match(/^\\s*<([-\\w]+)/),\n        tagName = match && match[1].toLowerCase(),\n        rootTag = rootEls[tagName] || GENERIC,\n        el = mkEl(rootTag)\n\n    el.stub = true\n\n    if (checkIE && tagName && (match = tagName.match(SPECIAL_TAGS_REGEX)))\n      ie9elem(el, html, tagName, !!match[1])\n    else\n      el.innerHTML = html\n\n    return el\n  }\n\n  // creates tr, th, td, option, optgroup element for IE8-9\n  /* istanbul ignore next */\n  function ie9elem(el, html, tagName, select) {\n\n    var div = mkEl(GENERIC),\n        tag = select ? 'select>' : 'table>',\n        child\n\n    div.innerHTML = '<' + tag + html + '</' + tag\n\n    child = div.getElementsByTagName(tagName)[0]\n    if (child)\n      el.appendChild(child)\n\n  }\n  // end ie9elem()\n\n  return _mkdom\n\n})(IE_VERSION)\n\n// { key, i in items} -> { key, i, items }\nfunction loopKeys(expr) {\n  var b0 = brackets(0),\n      els = expr.trim().slice(b0.length).match(/^\\s*(\\S+?)\\s*(?:,\\s*(\\S+))?\\s+in\\s+(.+)$/)\n  return els ? { key: els[1], pos: els[2], val: b0 + els[3] } : { val: expr }\n}\n\nfunction mkitem(expr, key, val) {\n  var item = {}\n  item[expr.key] = key\n  if (expr.pos) item[expr.pos] = val\n  return item\n}\n\n\n/* Beware: heavy stuff */\nfunction _each(dom, parent, expr) {\n\n  remAttr(dom, 'each')\n\n  var tagName = getTagName(dom),\n      template = dom.outerHTML,\n      hasImpl = !!tagImpl[tagName],\n      impl = tagImpl[tagName] || {\n        tmpl: template\n      },\n      root = dom.parentNode,\n      placeholder = document.createComment('riot placeholder'),\n      tags = [],\n      child = getTag(dom),\n      checksum\n\n  root.insertBefore(placeholder, dom)\n\n  expr = loopKeys(expr)\n\n  // clean template code\n  parent\n    .one('premount', function () {\n      if (root.stub) root = parent.root\n      // remove the original DOM node\n      dom.parentNode.removeChild(dom)\n    })\n    .on('update', function () {\n      var items = tmpl(expr.val, parent)\n\n      // object loop. any changes cause full redraw\n      if (!isArray(items)) {\n\n        checksum = items ? JSON.stringify(items) : ''\n\n        items = !items ? [] :\n          Object.keys(items).map(function (key) {\n            return mkitem(expr, key, items[key])\n          })\n      }\n\n      var frag = document.createDocumentFragment(),\n          i = tags.length,\n          j = items.length\n\n      // unmount leftover items\n      while (i > j) {\n        tags[--i].unmount()\n        tags.splice(i, 1)\n      }\n\n      for (i = 0; i < j; ++i) {\n        var _item = !checksum && !!expr.key ? mkitem(expr, items[i], i) : items[i]\n\n        if (!tags[i]) {\n          // mount new\n          (tags[i] = new Tag(impl, {\n              parent: parent,\n              isLoop: true,\n              hasImpl: hasImpl,\n              root: SPECIAL_TAGS_REGEX.test(tagName) ? root : dom.cloneNode(),\n              item: _item\n            }, dom.innerHTML)\n          ).mount()\n\n          frag.appendChild(tags[i].root)\n        } else\n          tags[i].update(_item)\n\n        tags[i]._item = _item\n\n      }\n\n      root.insertBefore(frag, placeholder)\n\n      if (child) parent.tags[tagName] = tags\n\n    }).one('updated', function() {\n      var keys = Object.keys(parent)// only set new values\n      walk(root, function(node) {\n        // only set element node and not isLoop\n        if (node.nodeType == 1 && !node.isLoop && !node._looped) {\n          node._visited = false // reset _visited for loop node\n          node._looped = true // avoid set multiple each\n          setNamed(node, parent, keys)\n        }\n      })\n    })\n\n}\n\n\nfunction parseNamedElements(root, tag, childTags) {\n\n  walk(root, function(dom) {\n    if (dom.nodeType == 1) {\n      dom.isLoop = dom.isLoop || (dom.parentNode && dom.parentNode.isLoop || dom.getAttribute('each')) ? 1 : 0\n\n      // custom child tag\n      var child = getTag(dom)\n\n      if (child && !dom.isLoop) {\n        childTags.push(initChildTag(child, dom, tag))\n      }\n\n      if (!dom.isLoop)\n        setNamed(dom, tag, [])\n    }\n\n  })\n\n}\n\nfunction parseExpressions(root, tag, expressions) {\n\n  function addExpr(dom, val, extra) {\n    if (val.indexOf(brackets(0)) >= 0) {\n      var expr = { dom: dom, expr: val }\n      expressions.push(extend(expr, extra))\n    }\n  }\n\n  walk(root, function(dom) {\n    var type = dom.nodeType\n\n    // text node\n    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n    if (type != 1) return\n\n    /* element */\n\n    // loop\n    var attr = dom.getAttribute('each')\n\n    if (attr) { _each(dom, tag, attr); return false }\n\n    // attribute expressions\n    each(dom.attributes, function(attr) {\n      var name = attr.name,\n        bool = name.split('__')[1]\n\n      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n      if (bool) { remAttr(dom, name); return false }\n\n    })\n\n    // skip custom tags\n    if (getTag(dom)) return false\n\n  })\n\n}\nfunction Tag(impl, conf, innerHTML) {\n\n  var self = riot.observable(this),\n      opts = inherit(conf.opts) || {},\n      dom = mkdom(impl.tmpl),\n      parent = conf.parent,\n      isLoop = conf.isLoop,\n      hasImpl = conf.hasImpl,\n      item = cleanUpData(conf.item),\n      expressions = [],\n      childTags = [],\n      root = conf.root,\n      fn = impl.fn,\n      tagName = root.tagName.toLowerCase(),\n      attr = {},\n      propsInSyncWithParent = []\n\n  if (fn && root._tag) {\n    root._tag.unmount(true)\n  }\n\n  // not yet mounted\n  this.isMounted = false\n  root.isLoop = isLoop\n\n  // keep a reference to the tag just created\n  // so we will be able to mount this tag multiple times\n  root._tag = this\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  this._id = __uid++\n\n  extend(this, { parent: parent, root: root, opts: opts, tags: {} }, item)\n\n  // grab attributes\n  each(root.attributes, function(el) {\n    var val = el.value\n    // remember attributes with expressions only\n    if (brackets(/{.*}/).test(val)) attr[el.name] = val\n  })\n\n  if (dom.innerHTML && !/^(select|optgroup|table|tbody|tr|col(?:group)?)$/.test(tagName))\n    // replace all the yield tags with the tag inner html\n    dom.innerHTML = replaceYield(dom.innerHTML, innerHTML)\n\n  // options\n  function updateOpts() {\n    var ctx = hasImpl && isLoop ? self : parent || self\n\n    // update opts from current DOM attributes\n    each(root.attributes, function(el) {\n      opts[el.name] = tmpl(el.value, ctx)\n    })\n    // recover those with expressions\n    each(Object.keys(attr), function(name) {\n      opts[name] = tmpl(attr[name], ctx)\n    })\n  }\n\n  function normalizeData(data) {\n    for (var key in item) {\n      if (typeof self[key] !== T_UNDEF)\n        self[key] = data[key]\n    }\n  }\n\n  function inheritFromParent () {\n    if (!self.parent || !isLoop) return\n    each(Object.keys(self.parent), function(k) {\n      // some properties must be always in sync with the parent tag\n      var mustSync = !~RESERVED_WORDS_BLACKLIST.indexOf(k) && ~propsInSyncWithParent.indexOf(k)\n      if (typeof self[k] === T_UNDEF || mustSync) {\n        // track the property to keep in sync\n        // so we can keep it updated\n        if (!mustSync) propsInSyncWithParent.push(k)\n        self[k] = self.parent[k]\n      }\n    })\n  }\n\n  this.update = function(data) {\n    // make sure the data passed will not override\n    // the component core methods\n    data = cleanUpData(data)\n    // inherit properties from the parent\n    inheritFromParent()\n    // normalize the tag properties in case an item object was initially passed\n    if (data && typeof item === T_OBJECT) {\n      normalizeData(data)\n      item = data\n    }\n    extend(self, data)\n    updateOpts()\n    self.trigger('update', data)\n    update(expressions, self)\n    self.trigger('updated')\n  }\n\n  this.mixin = function() {\n    each(arguments, function(mix) {\n      mix = typeof mix === T_STRING ? riot.mixin(mix) : mix\n      each(Object.keys(mix), function(key) {\n        // bind methods to self\n        if (key != 'init')\n          self[key] = isFunction(mix[key]) ? mix[key].bind(self) : mix[key]\n      })\n      // init method will be called automatically\n      if (mix.init) mix.init.bind(self)()\n    })\n  }\n\n  this.mount = function() {\n\n    updateOpts()\n\n    // initialiation\n    if (fn) fn.call(self, opts)\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions(dom, self, expressions)\n\n    // mount the child tags\n    toggle(true)\n\n    // update the root adding custom attributes coming from the compiler\n    // it fixes also #1087\n    if (impl.attrs || hasImpl) {\n      walkAttributes(impl.attrs, function (k, v) { root.setAttribute(k, v) })\n      parseExpressions(self.root, self, expressions)\n    }\n\n    if (!self.parent || isLoop) self.update(item)\n\n    // internal use only, fixes #403\n    self.trigger('premount')\n\n    if (isLoop && !hasImpl) {\n      // update the root attribute for the looped elements\n      self.root = root = dom.firstChild\n\n    } else {\n      while (dom.firstChild) root.appendChild(dom.firstChild)\n      if (root.stub) self.root = root = parent.root\n    }\n    // if it's not a child tag we can trigger its mount event\n    if (!self.parent || self.parent.isMounted) {\n      self.isMounted = true\n      self.trigger('mount')\n    }\n    // otherwise we need to wait that the parent event gets triggered\n    else self.parent.one('mount', function() {\n      // avoid to trigger the `mount` event for the tags\n      // not visible included in an if statement\n      if (!isInStub(self.root)) {\n        self.parent.isMounted = self.isMounted = true\n        self.trigger('mount')\n      }\n    })\n  }\n\n\n  this.unmount = function(keepRootTag) {\n    var el = root,\n        p = el.parentNode,\n        ptag\n\n    if (p) {\n\n      if (parent) {\n        ptag = getImmediateCustomParentTag(parent)\n        // remove this tag from the parent tags object\n        // if there are multiple nested tags with same name..\n        // remove this element form the array\n        if (isArray(ptag.tags[tagName]))\n          each(ptag.tags[tagName], function(tag, i) {\n            if (tag._id == self._id)\n              ptag.tags[tagName].splice(i, 1)\n          })\n        else\n          // otherwise just delete the tag instance\n          ptag.tags[tagName] = undefined\n      }\n\n      else\n        while (el.firstChild) el.removeChild(el.firstChild)\n\n      if (!keepRootTag)\n        p.removeChild(el)\n      else\n        // the riot-tag attribute isn't needed anymore, remove it\n        p.removeAttribute('riot-tag')\n    }\n\n\n    self.trigger('unmount')\n    toggle()\n    self.off('*')\n    // somehow ie8 does not like `delete root._tag`\n    root._tag = null\n\n  }\n\n  function toggle(isMount) {\n\n    // mount/unmount children\n    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })\n\n    // listen/unlisten parent (events flow one way from parent to children)\n    if (parent) {\n      var evt = isMount ? 'on' : 'off'\n\n      // the loop tags will be always in sync with the parent automatically\n      if (isLoop)\n        parent[evt]('unmount', self.unmount)\n      else\n        parent[evt]('update', self.update)[evt]('unmount', self.unmount)\n    }\n  }\n\n  // named elements available for fn\n  parseNamedElements(dom, this, childTags)\n\n\n}\n\nfunction setEventHandler(name, handler, dom, tag) {\n\n  dom[name] = function(e) {\n\n    var item = tag._item,\n        ptag = tag.parent,\n        el\n\n    if (!item)\n      while (ptag && !item) {\n        item = ptag._item\n        ptag = ptag.parent\n      }\n\n    // cross browser event fix\n    e = e || window.event\n\n    // ignore error on some browsers\n    try {\n      e.currentTarget = dom\n      if (!e.target) e.target = e.srcElement\n      if (!e.which) e.which = e.charCode || e.keyCode\n    } catch (ignored) { /**/ }\n\n    e.item = item\n\n    // prevent default behaviour (by default)\n    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n      if (e.preventDefault) e.preventDefault()\n      e.returnValue = false\n    }\n\n    if (!e.preventUpdate) {\n      el = item ? getImmediateCustomParentTag(ptag) : tag\n      el.update()\n    }\n\n  }\n\n}\n\n// used by if- attribute\nfunction insertTo(root, node, before) {\n  if (root) {\n    root.insertBefore(before, node)\n    root.removeChild(node)\n  }\n}\n\nfunction update(expressions, tag) {\n\n  each(expressions, function(expr, i) {\n\n    var dom = expr.dom,\n        attrName = expr.attr,\n        value = tmpl(expr.expr, tag),\n        parent = expr.dom.parentNode\n\n    if (expr.bool)\n      value = value ? attrName : false\n    else if (value == null)\n      value = ''\n\n    // leave out riot- prefixes from strings inside textarea\n    // fix #815: any value -> string\n    if (parent && parent.tagName == 'TEXTAREA') value = ('' + value).replace(/riot-/g, '')\n\n    // no change\n    if (expr.value === value) return\n    expr.value = value\n\n    // text node\n    if (!attrName) {\n      dom.nodeValue = '' + value    // #815 related\n      return\n    }\n\n    // remove original attribute\n    remAttr(dom, attrName)\n    // event handler\n    if (isFunction(value)) {\n      setEventHandler(attrName, value, dom, tag)\n\n    // if- conditional\n    } else if (attrName == 'if') {\n      var stub = expr.stub,\n          add = function() { insertTo(stub.parentNode, stub, dom) },\n          remove = function() { insertTo(dom.parentNode, dom, stub) }\n\n      // add to DOM\n      if (value) {\n        if (stub) {\n          add()\n          dom.inStub = false\n          // avoid to trigger the mount event if the tags is not visible yet\n          // maybe we can optimize this avoiding to mount the tag at all\n          if (!isInStub(dom)) {\n            walk(dom, function(el) {\n              if (el._tag && !el._tag.isMounted) el._tag.isMounted = !!el._tag.trigger('mount')\n            })\n          }\n        }\n      // remove from DOM\n      } else {\n        stub = expr.stub = stub || document.createTextNode('')\n        // if the parentNode is defined we can easily replace the tag\n        if (dom.parentNode)\n          remove()\n        else\n        // otherwise we need to wait the updated event\n          (tag.parent || tag).one('updated', remove)\n\n        dom.inStub = true\n      }\n    // show / hide\n    } else if (/^(show|hide)$/.test(attrName)) {\n      if (attrName == 'hide') value = !value\n      dom.style.display = value ? '' : 'none'\n\n    // field value\n    } else if (attrName == 'value') {\n      dom.value = value\n\n    // <img src=\"{ expr }\">\n    } else if (startsWith(attrName, RIOT_PREFIX) && attrName != RIOT_TAG) {\n      if (value)\n        dom.setAttribute(attrName.slice(RIOT_PREFIX.length), value)\n\n    } else {\n      if (expr.bool) {\n        dom[attrName] = value\n        if (!value) return\n      }\n\n      if (typeof value !== T_OBJECT) dom.setAttribute(attrName, value)\n\n    }\n\n  })\n\n}\nfunction each(els, fn) {\n  for (var i = 0, len = (els || []).length, el; i < len; i++) {\n    el = els[i]\n    // return false -> remove current item during loop\n    if (el != null && fn(el, i) === false) i--\n  }\n  return els\n}\n\nfunction isFunction(v) {\n  return typeof v === T_FUNCTION || false   // avoid IE problems\n}\n\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name)\n}\n\nfunction getTag(dom) {\n  return dom.tagName && tagImpl[dom.getAttribute(RIOT_TAG) || dom.tagName.toLowerCase()]\n}\n\nfunction initChildTag(child, dom, parent) {\n  var tag = new Tag(child, { root: dom, parent: parent }, dom.innerHTML),\n      tagName = getTagName(dom),\n      ptag = getImmediateCustomParentTag(parent),\n      cachedTag\n\n  // fix for the parent attribute in the looped elements\n  tag.parent = ptag\n\n  cachedTag = ptag.tags[tagName]\n\n  // if there are multiple children tags having the same name\n  if (cachedTag) {\n    // if the parent tags property is not yet an array\n    // create it adding the first cached tag\n    if (!isArray(cachedTag))\n      ptag.tags[tagName] = [cachedTag]\n    // add the new nested tag to the array\n    if (!~ptag.tags[tagName].indexOf(tag))\n      ptag.tags[tagName].push(tag)\n  } else {\n    ptag.tags[tagName] = tag\n  }\n\n  // empty the child node once we got its template\n  // to avoid that its children get compiled multiple times\n  dom.innerHTML = ''\n\n  return tag\n}\n\nfunction getImmediateCustomParentTag(tag) {\n  var ptag = tag\n  while (!getTag(ptag.root)) {\n    if (!ptag.parent) break\n    ptag = ptag.parent\n  }\n  return ptag\n}\n\nfunction getTagName(dom) {\n  var child = getTag(dom),\n    namedTag = dom.getAttribute('name'),\n    tagName = namedTag && namedTag.indexOf(brackets(0)) < 0 ? namedTag : child ? child.name : dom.tagName.toLowerCase()\n\n  return tagName\n}\n\nfunction extend(src) {\n  var obj, args = arguments\n  for (var i = 1; i < args.length; ++i) {\n    if ((obj = args[i])) {\n      for (var key in obj) {      // eslint-disable-line guard-for-in\n        src[key] = obj[key]\n      }\n    }\n  }\n  return src\n}\n\n// with this function we avoid that the current Tag methods get overridden\nfunction cleanUpData(data) {\n  if (!(data instanceof Tag) && !(data && typeof data.trigger == T_FUNCTION)) return data\n\n  var o = {}\n  for (var key in data) {\n    if (!~RESERVED_WORDS_BLACKLIST.indexOf(key))\n      o[key] = data[key]\n  }\n  return o\n}\n\nfunction walk(dom, fn) {\n  if (dom) {\n    if (fn(dom) === false) return\n    else {\n      dom = dom.firstChild\n\n      while (dom) {\n        walk(dom, fn)\n        dom = dom.nextSibling\n      }\n    }\n  }\n}\n\n// minimize risk: only zero or one _space_ between attr & value\nfunction walkAttributes(html, fn) {\n  var m,\n      re = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g\n\n  while ((m = re.exec(html))) {\n    fn(m[1].toLowerCase(), m[2] || m[3] || m[4])\n  }\n}\n\nfunction isInStub(dom) {\n  while (dom) {\n    if (dom.inStub) return true\n    dom = dom.parentNode\n  }\n  return false\n}\n\nfunction mkEl(name) {\n  return document.createElement(name)\n}\n\nfunction replaceYield(tmpl, innerHTML) {\n  return tmpl.replace(/<(yield)\\/?>(<\\/\\1>)?/gi, innerHTML || '')\n}\n\nfunction $$(selector, ctx) {\n  return (ctx || document).querySelectorAll(selector)\n}\n\nfunction $(selector, ctx) {\n  return (ctx || document).querySelector(selector)\n}\n\nfunction inherit(parent) {\n  function Child() {}\n  Child.prototype = parent\n  return new Child()\n}\n\nfunction setNamed(dom, parent, keys) {\n  if (dom._visited) return\n  var p,\n      v = dom.getAttribute('id') || dom.getAttribute('name')\n\n  if (v) {\n    if (keys.indexOf(v) < 0) {\n      p = parent[v]\n      if (!p)\n        parent[v] = dom\n      else if (isArray(p))\n        p.push(dom)\n      else\n        parent[v] = [p, dom]\n    }\n    dom._visited = true\n  }\n}\n\n// faster String startsWith alternative\nfunction startsWith(src, str) {\n  return src.slice(0, str.length) === str\n}\n\n/*\n Virtual dom is an array of custom tags on the document.\n Updates and unmounts propagate downwards from parent to children.\n*/\n\nvar virtualDom = [],\n    tagImpl = {},\n    styleNode\n\nfunction injectStyle(css) {\n\n  if (riot.render) return // skip injection on the server\n\n  if (!styleNode) {\n    styleNode = mkEl('style')\n    styleNode.setAttribute('type', 'text/css')\n  }\n\n  var head = document.head || document.getElementsByTagName('head')[0]\n\n  if (styleNode.styleSheet)\n    styleNode.styleSheet.cssText += css\n  else\n    styleNode.innerHTML += css\n\n  if (!styleNode._rendered)\n    if (styleNode.styleSheet) {\n      document.body.appendChild(styleNode)\n    } else {\n      var rs = $('style[type=riot]')\n      if (rs) {\n        rs.parentNode.insertBefore(styleNode, rs)\n        rs.parentNode.removeChild(rs)\n      } else head.appendChild(styleNode)\n\n    }\n\n  styleNode._rendered = true\n\n}\n\nfunction mountTo(root, tagName, opts) {\n  var tag = tagImpl[tagName],\n      // cache the inner HTML to fix #855\n      innerHTML = root._innerHTML = root._innerHTML || root.innerHTML\n\n  // clear the inner html\n  root.innerHTML = ''\n\n  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)\n\n  if (tag && tag.mount) {\n    tag.mount()\n    virtualDom.push(tag)\n    return tag.on('unmount', function() {\n      virtualDom.splice(virtualDom.indexOf(tag), 1)\n    })\n  }\n\n}\n\nriot.tag = function(name, html, css, attrs, fn) {\n  if (isFunction(attrs)) {\n    fn = attrs\n    if (/^[\\w\\-]+\\s?=/.test(css)) {\n      attrs = css\n      css = ''\n    } else attrs = ''\n  }\n  if (css) {\n    if (isFunction(css)) fn = css\n    else injectStyle(css)\n  }\n  tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\nriot.mount = function(selector, tagName, opts) {\n\n  var els,\n      allTags,\n      tags = []\n\n  // helper functions\n\n  function addRiotTags(arr) {\n    var list = ''\n    each(arr, function (e) {\n      list += ', *[' + RIOT_TAG + '=\"' + e.trim() + '\"]'\n    })\n    return list\n  }\n\n  function selectAllTags() {\n    var keys = Object.keys(tagImpl)\n    return keys + addRiotTags(keys)\n  }\n\n  function pushTags(root) {\n    var last\n    if (root.tagName) {\n      if (tagName && (!(last = root.getAttribute(RIOT_TAG)) || last != tagName))\n        root.setAttribute(RIOT_TAG, tagName)\n\n      var tag = mountTo(root,\n        tagName || root.getAttribute(RIOT_TAG) || root.tagName.toLowerCase(), opts)\n\n      if (tag) tags.push(tag)\n    }\n    else if (root.length) {\n      each(root, pushTags)   // assume nodeList\n    }\n  }\n\n  // ----- mount code -----\n\n  if (typeof tagName === T_OBJECT) {\n    opts = tagName\n    tagName = 0\n  }\n\n  // crawl the DOM to find the tag\n  if (typeof selector === T_STRING) {\n    if (selector === '*')\n      // select all the tags registered\n      // and also the tags found with the riot-tag attribute set\n      selector = allTags = selectAllTags()\n    else\n      // or just the ones named like the selector\n      selector += addRiotTags(selector.split(','))\n\n    els = $$(selector)\n  }\n  else\n    // probably you have passed already a tag or a NodeList\n    els = selector\n\n  // select all the registered and mount them inside their root elements\n  if (tagName === '*') {\n    // get all custom tags\n    tagName = allTags || selectAllTags()\n    // if the root els it's just a single tag\n    if (els.tagName)\n      els = $$(tagName, els)\n    else {\n      // select all the children for all the different root elements\n      var nodeList = []\n      each(els, function (_el) {\n        nodeList.push($$(tagName, _el))\n      })\n      els = nodeList\n    }\n    // get rid of the tagName\n    tagName = 0\n  }\n\n  if (els.tagName)\n    pushTags(els)\n  else\n    each(els, pushTags)\n\n  return tags\n}\n\n// update everything\nriot.update = function() {\n  return each(virtualDom, function(tag) {\n    tag.update()\n  })\n}\n\n// @deprecated\nriot.mountTo = riot.mount\n\n  // share methods for other riot parts, e.g. compiler\n  riot.util = { brackets: brackets, tmpl: tmpl }\n\n  // support CommonJS, AMD & browser\n  /* istanbul ignore next */\n  if (typeof exports === T_OBJECT)\n    module.exports = riot\n  else if (typeof define === 'function' && define.amd)\n    define(function() { return (window.riot = riot) })\n  else\n    window.riot = riot\n\n})(typeof window != 'undefined' ? window : void 0);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/riot/riot.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\n * Module dependencies.\n */\n\nvar Emitter = require('emitter');\nvar reduce = require('reduce');\n\n/**\n * Root reference for iframes.\n */\n\nvar root;\nif (typeof window !== 'undefined') { // Browser window\n  root = window;\n} else if (typeof self !== 'undefined') { // Web Worker\n  root = self;\n} else { // Other environments\n  root = this;\n}\n\n/**\n * Noop.\n */\n\nfunction noop(){};\n\n/**\n * Check if `obj` is a host object,\n * we don't want to serialize these :)\n *\n * TODO: future proof, move to compoent land\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isHost(obj) {\n  var str = {}.toString.call(obj);\n\n  switch (str) {\n    case '[object File]':\n    case '[object Blob]':\n    case '[object FormData]':\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Determine XHR.\n */\n\nrequest.getXHR = function () {\n  if (root.XMLHttpRequest\n      && (!root.location || 'file:' != root.location.protocol\n          || !root.ActiveXObject)) {\n    return new XMLHttpRequest;\n  } else {\n    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n  }\n  return false;\n};\n\n/**\n * Removes leading and trailing whitespace, added to support IE.\n *\n * @param {String} s\n * @return {String}\n * @api private\n */\n\nvar trim = ''.trim\n  ? function(s) { return s.trim(); }\n  : function(s) { return s.replace(/(^\\s*|\\s*$)/g, ''); };\n\n/**\n * Check if `obj` is an object.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isObject(obj) {\n  return obj === Object(obj);\n}\n\n/**\n * Serialize the given `obj`.\n *\n * @param {Object} obj\n * @return {String}\n * @api private\n */\n\nfunction serialize(obj) {\n  if (!isObject(obj)) return obj;\n  var pairs = [];\n  for (var key in obj) {\n    if (null != obj[key]) {\n      pairs.push(encodeURIComponent(key)\n        + '=' + encodeURIComponent(obj[key]));\n    }\n  }\n  return pairs.join('&');\n}\n\n/**\n * Expose serialization method.\n */\n\n request.serializeObject = serialize;\n\n /**\n  * Parse the given x-www-form-urlencoded `str`.\n  *\n  * @param {String} str\n  * @return {Object}\n  * @api private\n  */\n\nfunction parseString(str) {\n  var obj = {};\n  var pairs = str.split('&');\n  var parts;\n  var pair;\n\n  for (var i = 0, len = pairs.length; i < len; ++i) {\n    pair = pairs[i];\n    parts = pair.split('=');\n    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);\n  }\n\n  return obj;\n}\n\n/**\n * Expose parser.\n */\n\nrequest.parseString = parseString;\n\n/**\n * Default MIME type map.\n *\n *     superagent.types.xml = 'application/xml';\n *\n */\n\nrequest.types = {\n  html: 'text/html',\n  json: 'application/json',\n  xml: 'application/xml',\n  urlencoded: 'application/x-www-form-urlencoded',\n  'form': 'application/x-www-form-urlencoded',\n  'form-data': 'application/x-www-form-urlencoded'\n};\n\n/**\n * Default serialization map.\n *\n *     superagent.serialize['application/xml'] = function(obj){\n *       return 'generated xml here';\n *     };\n *\n */\n\n request.serialize = {\n   'application/x-www-form-urlencoded': serialize,\n   'application/json': JSON.stringify\n };\n\n /**\n  * Default parsers.\n  *\n  *     superagent.parse['application/xml'] = function(str){\n  *       return { object parsed from str };\n  *     };\n  *\n  */\n\nrequest.parse = {\n  'application/x-www-form-urlencoded': parseString,\n  'application/json': JSON.parse\n};\n\n/**\n * Parse the given header `str` into\n * an object containing the mapped fields.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction parseHeader(str) {\n  var lines = str.split(/\\r?\\n/);\n  var fields = {};\n  var index;\n  var line;\n  var field;\n  var val;\n\n  lines.pop(); // trailing CRLF\n\n  for (var i = 0, len = lines.length; i < len; ++i) {\n    line = lines[i];\n    index = line.indexOf(':');\n    field = line.slice(0, index).toLowerCase();\n    val = trim(line.slice(index + 1));\n    fields[field] = val;\n  }\n\n  return fields;\n}\n\n/**\n * Return the mime type for the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nfunction type(str){\n  return str.split(/ *; */).shift();\n};\n\n/**\n * Return header field parameters.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction params(str){\n  return reduce(str.split(/ *; */), function(obj, str){\n    var parts = str.split(/ *= */)\n      , key = parts.shift()\n      , val = parts.shift();\n\n    if (key && val) obj[key] = val;\n    return obj;\n  }, {});\n};\n\n/**\n * Initialize a new `Response` with the given `xhr`.\n *\n *  - set flags (.ok, .error, etc)\n *  - parse header\n *\n * Examples:\n *\n *  Aliasing `superagent` as `request` is nice:\n *\n *      request = superagent;\n *\n *  We can use the promise-like API, or pass callbacks:\n *\n *      request.get('/').end(function(res){});\n *      request.get('/', function(res){});\n *\n *  Sending data can be chained:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' })\n *        .end(function(res){});\n *\n *  Or passed to `.send()`:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' }, function(res){});\n *\n *  Or passed to `.post()`:\n *\n *      request\n *        .post('/user', { name: 'tj' })\n *        .end(function(res){});\n *\n * Or further reduced to a single call for simple cases:\n *\n *      request\n *        .post('/user', { name: 'tj' }, function(res){});\n *\n * @param {XMLHTTPRequest} xhr\n * @param {Object} options\n * @api private\n */\n\nfunction Response(req, options) {\n  options = options || {};\n  this.req = req;\n  this.xhr = this.req.xhr;\n  // responseText is accessible only if responseType is '' or 'text' and on older browsers\n  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')\n     ? this.xhr.responseText\n     : null;\n  this.statusText = this.req.xhr.statusText;\n  this.setStatusProperties(this.xhr.status);\n  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());\n  // getAllResponseHeaders sometimes falsely returns \"\" for CORS requests, but\n  // getResponseHeader still works. so we get content-type even if getting\n  // other headers fails.\n  this.header['content-type'] = this.xhr.getResponseHeader('content-type');\n  this.setHeaderProperties(this.header);\n  this.body = this.req.method != 'HEAD'\n    ? this.parseBody(this.text ? this.text : this.xhr.response)\n    : null;\n}\n\n/**\n * Get case-insensitive `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nResponse.prototype.get = function(field){\n  return this.header[field.toLowerCase()];\n};\n\n/**\n * Set header related properties:\n *\n *   - `.type` the content type without params\n *\n * A response of \"Content-Type: text/plain; charset=utf-8\"\n * will provide you with a `.type` of \"text/plain\".\n *\n * @param {Object} header\n * @api private\n */\n\nResponse.prototype.setHeaderProperties = function(header){\n  // content-type\n  var ct = this.header['content-type'] || '';\n  this.type = type(ct);\n\n  // params\n  var obj = params(ct);\n  for (var key in obj) this[key] = obj[key];\n};\n\n/**\n * Force given parser\n * \n * Sets the body parser no matter type.\n * \n * @param {Function}\n * @api public\n */\n\nResponse.prototype.parse = function(fn){\n  this.parser = fn;\n  return this;\n};\n\n/**\n * Parse the given body `str`.\n *\n * Used for auto-parsing of bodies. Parsers\n * are defined on the `superagent.parse` object.\n *\n * @param {String} str\n * @return {Mixed}\n * @api private\n */\n\nResponse.prototype.parseBody = function(str){\n  var parse = this.parser || request.parse[this.type];\n  return parse && str && (str.length || str instanceof Object)\n    ? parse(str)\n    : null;\n};\n\n/**\n * Set flags such as `.ok` based on `status`.\n *\n * For example a 2xx response will give you a `.ok` of __true__\n * whereas 5xx will be __false__ and `.error` will be __true__. The\n * `.clientError` and `.serverError` are also available to be more\n * specific, and `.statusType` is the class of error ranging from 1..5\n * sometimes useful for mapping respond colors etc.\n *\n * \"sugar\" properties are also defined for common cases. Currently providing:\n *\n *   - .noContent\n *   - .badRequest\n *   - .unauthorized\n *   - .notAcceptable\n *   - .notFound\n *\n * @param {Number} status\n * @api private\n */\n\nResponse.prototype.setStatusProperties = function(status){\n  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n  if (status === 1223) {\n    status = 204;\n  }\n\n  var type = status / 100 | 0;\n\n  // status / class\n  this.status = this.statusCode = status;\n  this.statusType = type;\n\n  // basics\n  this.info = 1 == type;\n  this.ok = 2 == type;\n  this.clientError = 4 == type;\n  this.serverError = 5 == type;\n  this.error = (4 == type || 5 == type)\n    ? this.toError()\n    : false;\n\n  // sugar\n  this.accepted = 202 == status;\n  this.noContent = 204 == status;\n  this.badRequest = 400 == status;\n  this.unauthorized = 401 == status;\n  this.notAcceptable = 406 == status;\n  this.notFound = 404 == status;\n  this.forbidden = 403 == status;\n};\n\n/**\n * Return an `Error` representative of this response.\n *\n * @return {Error}\n * @api public\n */\n\nResponse.prototype.toError = function(){\n  var req = this.req;\n  var method = req.method;\n  var url = req.url;\n\n  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';\n  var err = new Error(msg);\n  err.status = this.status;\n  err.method = method;\n  err.url = url;\n\n  return err;\n};\n\n/**\n * Expose `Response`.\n */\n\nrequest.Response = Response;\n\n/**\n * Initialize a new `Request` with the given `method` and `url`.\n *\n * @param {String} method\n * @param {String} url\n * @api public\n */\n\nfunction Request(method, url) {\n  var self = this;\n  Emitter.call(this);\n  this._query = this._query || [];\n  this.method = method;\n  this.url = url;\n  this.header = {};\n  this._header = {};\n  this.on('end', function(){\n    var err = null;\n    var res = null;\n\n    try {\n      res = new Response(self);\n    } catch(e) {\n      err = new Error('Parser is unable to parse the response');\n      err.parse = true;\n      err.original = e;\n      return self.callback(err);\n    }\n\n    self.emit('response', res);\n\n    if (err) {\n      return self.callback(err, res);\n    }\n\n    if (res.status >= 200 && res.status < 300) {\n      return self.callback(err, res);\n    }\n\n    var new_err = new Error(res.statusText || 'Unsuccessful HTTP response');\n    new_err.original = err;\n    new_err.response = res;\n    new_err.status = res.status;\n\n    self.callback(new_err, res);\n  });\n}\n\n/**\n * Mixin `Emitter`.\n */\n\nEmitter(Request.prototype);\n\n/**\n * Allow for extension\n */\n\nRequest.prototype.use = function(fn) {\n  fn(this);\n  return this;\n}\n\n/**\n * Set timeout to `ms`.\n *\n * @param {Number} ms\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.timeout = function(ms){\n  this._timeout = ms;\n  return this;\n};\n\n/**\n * Clear previous timeout.\n *\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.clearTimeout = function(){\n  this._timeout = 0;\n  clearTimeout(this._timer);\n  return this;\n};\n\n/**\n * Abort the request, and clear potential timeout.\n *\n * @return {Request}\n * @api public\n */\n\nRequest.prototype.abort = function(){\n  if (this.aborted) return;\n  this.aborted = true;\n  this.xhr.abort();\n  this.clearTimeout();\n  this.emit('abort');\n  return this;\n};\n\n/**\n * Set header `field` to `val`, or multiple fields with one object.\n *\n * Examples:\n *\n *      req.get('/')\n *        .set('Accept', 'application/json')\n *        .set('X-API-Key', 'foobar')\n *        .end(callback);\n *\n *      req.get('/')\n *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })\n *        .end(callback);\n *\n * @param {String|Object} field\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.set = function(field, val){\n  if (isObject(field)) {\n    for (var key in field) {\n      this.set(key, field[key]);\n    }\n    return this;\n  }\n  this._header[field.toLowerCase()] = val;\n  this.header[field] = val;\n  return this;\n};\n\n/**\n * Remove header `field`.\n *\n * Example:\n *\n *      req.get('/')\n *        .unset('User-Agent')\n *        .end(callback);\n *\n * @param {String} field\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.unset = function(field){\n  delete this._header[field.toLowerCase()];\n  delete this.header[field];\n  return this;\n};\n\n/**\n * Get case-insensitive header `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api private\n */\n\nRequest.prototype.getHeader = function(field){\n  return this._header[field.toLowerCase()];\n};\n\n/**\n * Set Content-Type to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.xml = 'application/xml';\n *\n *      request.post('/')\n *        .type('xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n *      request.post('/')\n *        .type('application/xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n * @param {String} type\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.type = function(type){\n  this.set('Content-Type', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Accept to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.json = 'application/json';\n *\n *      request.get('/agent')\n *        .accept('json')\n *        .end(callback);\n *\n *      request.get('/agent')\n *        .accept('application/json')\n *        .end(callback);\n *\n * @param {String} accept\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.accept = function(type){\n  this.set('Accept', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Authorization field value with `user` and `pass`.\n *\n * @param {String} user\n * @param {String} pass\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.auth = function(user, pass){\n  var str = btoa(user + ':' + pass);\n  this.set('Authorization', 'Basic ' + str);\n  return this;\n};\n\n/**\n* Add query-string `val`.\n*\n* Examples:\n*\n*   request.get('/shoes')\n*     .query('size=10')\n*     .query({ color: 'blue' })\n*\n* @param {Object|String} val\n* @return {Request} for chaining\n* @api public\n*/\n\nRequest.prototype.query = function(val){\n  if ('string' != typeof val) val = serialize(val);\n  if (val) this._query.push(val);\n  return this;\n};\n\n/**\n * Write the field `name` and `val` for \"multipart/form-data\"\n * request bodies.\n *\n * ``` js\n * request.post('/upload')\n *   .field('foo', 'bar')\n *   .end(callback);\n * ```\n *\n * @param {String} name\n * @param {String|Blob|File} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.field = function(name, val){\n  if (!this._formData) this._formData = new root.FormData();\n  this._formData.append(name, val);\n  return this;\n};\n\n/**\n * Queue the given `file` as an attachment to the specified `field`,\n * with optional `filename`.\n *\n * ``` js\n * request.post('/upload')\n *   .attach(new Blob(['<a id=\"a\"><b id=\"b\">hey!</b></a>'], { type: \"text/html\"}))\n *   .end(callback);\n * ```\n *\n * @param {String} field\n * @param {Blob|File} file\n * @param {String} filename\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.attach = function(field, file, filename){\n  if (!this._formData) this._formData = new root.FormData();\n  this._formData.append(field, file, filename);\n  return this;\n};\n\n/**\n * Send `data`, defaulting the `.type()` to \"json\" when\n * an object is given.\n *\n * Examples:\n *\n *       // querystring\n *       request.get('/search')\n *         .end(callback)\n *\n *       // multiple data \"writes\"\n *       request.get('/search')\n *         .send({ search: 'query' })\n *         .send({ range: '1..5' })\n *         .send({ order: 'desc' })\n *         .end(callback)\n *\n *       // manual json\n *       request.post('/user')\n *         .type('json')\n *         .send('{\"name\":\"tj\"})\n *         .end(callback)\n *\n *       // auto json\n *       request.post('/user')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // manual x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send('name=tj')\n *         .end(callback)\n *\n *       // auto x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // defaults to x-www-form-urlencoded\n  *      request.post('/user')\n  *        .send('name=tobi')\n  *        .send('species=ferret')\n  *        .end(callback)\n *\n * @param {String|Object} data\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.send = function(data){\n  var obj = isObject(data);\n  var type = this.getHeader('Content-Type');\n\n  // merge\n  if (obj && isObject(this._data)) {\n    for (var key in data) {\n      this._data[key] = data[key];\n    }\n  } else if ('string' == typeof data) {\n    if (!type) this.type('form');\n    type = this.getHeader('Content-Type');\n    if ('application/x-www-form-urlencoded' == type) {\n      this._data = this._data\n        ? this._data + '&' + data\n        : data;\n    } else {\n      this._data = (this._data || '') + data;\n    }\n  } else {\n    this._data = data;\n  }\n\n  if (!obj || isHost(data)) return this;\n  if (!type) this.type('json');\n  return this;\n};\n\n/**\n * Invoke the callback with `err` and `res`\n * and handle arity check.\n *\n * @param {Error} err\n * @param {Response} res\n * @api private\n */\n\nRequest.prototype.callback = function(err, res){\n  var fn = this._callback;\n  this.clearTimeout();\n  fn(err, res);\n};\n\n/**\n * Invoke callback with x-domain error.\n *\n * @api private\n */\n\nRequest.prototype.crossDomainError = function(){\n  var err = new Error('Origin is not allowed by Access-Control-Allow-Origin');\n  err.crossDomain = true;\n  this.callback(err);\n};\n\n/**\n * Invoke callback with timeout error.\n *\n * @api private\n */\n\nRequest.prototype.timeoutError = function(){\n  var timeout = this._timeout;\n  var err = new Error('timeout of ' + timeout + 'ms exceeded');\n  err.timeout = timeout;\n  this.callback(err);\n};\n\n/**\n * Enable transmission of cookies with x-domain requests.\n *\n * Note that for this to work the origin must not be\n * using \"Access-Control-Allow-Origin\" with a wildcard,\n * and also must set \"Access-Control-Allow-Credentials\"\n * to \"true\".\n *\n * @api public\n */\n\nRequest.prototype.withCredentials = function(){\n  this._withCredentials = true;\n  return this;\n};\n\n/**\n * Initiate request, invoking callback `fn(res)`\n * with an instanceof `Response`.\n *\n * @param {Function} fn\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.end = function(fn){\n  var self = this;\n  var xhr = this.xhr = request.getXHR();\n  var query = this._query.join('&');\n  var timeout = this._timeout;\n  var data = this._formData || this._data;\n\n  // store callback\n  this._callback = fn || noop;\n\n  // state change\n  xhr.onreadystatechange = function(){\n    if (4 != xhr.readyState) return;\n\n    // In IE9, reads to any property (e.g. status) off of an aborted XHR will\n    // result in the error \"Could not complete the operation due to error c00c023f\"\n    var status;\n    try { status = xhr.status } catch(e) { status = 0; }\n\n    if (0 == status) {\n      if (self.timedout) return self.timeoutError();\n      if (self.aborted) return;\n      return self.crossDomainError();\n    }\n    self.emit('end');\n  };\n\n  // progress\n  var handleProgress = function(e){\n    if (e.total > 0) {\n      e.percent = e.loaded / e.total * 100;\n    }\n    self.emit('progress', e);\n  };\n  if (this.hasListeners('progress')) {\n    xhr.onprogress = handleProgress;\n  }\n  try {\n    if (xhr.upload && this.hasListeners('progress')) {\n      xhr.upload.onprogress = handleProgress;\n    }\n  } catch(e) {\n    // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.\n    // Reported here:\n    // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context\n  }\n\n  // timeout\n  if (timeout && !this._timer) {\n    this._timer = setTimeout(function(){\n      self.timedout = true;\n      self.abort();\n    }, timeout);\n  }\n\n  // querystring\n  if (query) {\n    query = request.serializeObject(query);\n    this.url += ~this.url.indexOf('?')\n      ? '&' + query\n      : '?' + query;\n  }\n\n  // initiate request\n  xhr.open(this.method, this.url, true);\n\n  // CORS\n  if (this._withCredentials) xhr.withCredentials = true;\n\n  // body\n  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {\n    // serialize stuff\n    var contentType = this.getHeader('Content-Type');\n    var serialize = request.serialize[contentType ? contentType.split(';')[0] : ''];\n    if (serialize) data = serialize(data);\n  }\n\n  // set header fields\n  for (var field in this.header) {\n    if (null == this.header[field]) continue;\n    xhr.setRequestHeader(field, this.header[field]);\n  }\n\n  // send stuff\n  this.emit('request', this);\n  xhr.send(data);\n  return this;\n};\n\n/**\n * Faux promise support\n *\n * @param {Function} fulfill\n * @param {Function} reject\n * @return {Request}\n */\n\nRequest.prototype.then = function (fulfill, reject) {\n  return this.end(function(err, res) {\n    err ? reject(err) : fulfill(res);\n  });\n}\n\n/**\n * Expose `Request`.\n */\n\nrequest.Request = Request;\n\n/**\n * Issue a request:\n *\n * Examples:\n *\n *    request('GET', '/users').end(callback)\n *    request('/users').end(callback)\n *    request('/users', callback)\n *\n * @param {String} method\n * @param {String|Function} url or callback\n * @return {Request}\n * @api public\n */\n\nfunction request(method, url) {\n  // callback\n  if ('function' == typeof url) {\n    return new Request('GET', method).end(url);\n  }\n\n  // url first\n  if (1 == arguments.length) {\n    return new Request('GET', method);\n  }\n\n  return new Request(method, url);\n}\n\n/**\n * GET `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.get = function(url, data, fn){\n  var req = request('GET', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.query(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * HEAD `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.head = function(url, data, fn){\n  var req = request('HEAD', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * DELETE `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.del = function(url, fn){\n  var req = request('DELETE', url);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * PATCH `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} data\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.patch = function(url, data, fn){\n  var req = request('PATCH', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * POST `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} data\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.post = function(url, data, fn){\n  var req = request('POST', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * PUT `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.put = function(url, data, fn){\n  var req = request('PUT', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * Expose `request`.\n */\n\nmodule.exports = request;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/superagent/lib/client.js\n ** module id = 2\n ** module chunks = 0\n **/","\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  var self = this;\n  this._callbacks = this._callbacks || {};\n\n  function on() {\n    self.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks[event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/superagent/~/component-emitter/index.js\n ** module id = 4\n ** module chunks = 0\n **/","\n/**\n * Reduce `arr` with `fn`.\n *\n * @param {Array} arr\n * @param {Function} fn\n * @param {Mixed} initial\n *\n * TODO: combatible error handling?\n */\n\nmodule.exports = function(arr, fn, initial){  \n  var idx = 0;\n  var len = arr.length;\n  var curr = arguments.length == 3\n    ? initial\n    : arr[idx++];\n\n  while (idx < len) {\n    curr = fn.call(null, curr, arr[idx], ++idx, arr);\n  }\n  \n  return curr;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/superagent/~/reduce-component/index.js\n ** module id = 5\n ** module chunks = 0\n **/"],"sourceRoot":""}