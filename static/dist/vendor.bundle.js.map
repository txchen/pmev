{"version":3,"sources":["webpack:///vendor.bundle.js","webpack:///webpack/bootstrap bebe61747b6407c199c2","webpack:///./static/src/vendor.js","webpack:///./~/riot/riot.js","webpack:///./~/superagent/lib/client.js","webpack:///./~/superagent/~/component-emitter/index.js","webpack:///./~/superagent/~/reduce-component/index.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","parentJsonpFunction","window","chunkIds","moreModules","chunkId","i","callbacks","length","installedChunks","push","apply","shift","e","callback","undefined","head","document","getElementsByTagName","script","createElement","type","charset","async","src","p","appendChild","m","c","loopKeys","expr","ret","val","els","split","brackets","slice","trim","key","pos","mkitem","item","_each","dom","parent","add","tag","rendered","splice","tags","remAttr","checksum","template","outerHTML","prev","previousSibling","root","parentNode","one","removeChild","stub","on","items","tmpl","Array","isArray","testsum","JSON","stringify","each","unmount","Object","keys","map","indexOf","newItems","arrFindEquals","oldItems","prevBase","childNodes","oldPos","lastIndexOf","nodes","_item","Tag","before","mount","update","insertBefore","walk","attributes","attr","test","name","value","parseNamedElements","childTags","nodeType","isLoop","getAttribute","child","getTag","cachedTag","innerHTML","namedTag","tagName","ptag","parseExpressions","expressions","addExpr","extra","extend","nodeValue","bool","impl","conf","updateOpts","opts","self","toggle","isMount","evt","loopDom","riot","observable","this","inherit","mkdom","fn","toLowerCase","TAG_ATTRIBUTES","_tag","attrs","match","a","kv","setAttribute","replace","_id","fastAbs","Date","getTime","Math","random","el","replaceYield","data","init","trigger","mixin","arguments","mix","bind","firstChild","keepRootTag","off","setEventHandler","handler","event","which","charCode","keyCode","target","srcElement","currentTarget","preventDefault","returnValue","preventUpdate","insertTo","node","attrName","toString","createTextNode","style","display","len","removeAttribute","nr","obj","from","from2","checkIE","ua","navigator","userAgent","msie","parseInt","substring","optionInnerHTML","html","opt","valRegx","selRegx","valuesMatch","selectedMatch","tbodyInnerHTML","div","rootTag","mkEl","ieVersion","nextSibling","$$","selector","ctx","querySelectorAll","arr","filter","_el","Child","prototype","loops","tagImpl","injectStyle","css","styleNode","styleSheet","cssText","_rendered","body","mountTo","virtualDom","version","settings","events","typed","cb","args","fns","busy","concat","all","registeredMixins","hash","loc","href","parser","path","emit","current","location","win","started","r","route","arg","exec","stop","removeEventListener","detachEvent","start","addEventListener","attachEvent","orig","s","b","x","RegExp","source","global","extract","Function","join","n","pair","_","k","v","wrap","nonull","reVars","str","substrings","parts","sub","open","close","level","matches","re","cache","allTags","selctAllTags","list","t","nodeList","util","noop","isHost","isObject","serialize","pairs","encodeURIComponent","parseString","decodeURIComponent","parseHeader","index","line","field","lines","fields","pop","params","reduce","Response","req","options","xhr","text","method","responseType","responseText","statusText","setStatusProperties","status","header","headers","getAllResponseHeaders","getResponseHeader","setHeaderProperties","parseBody","response","Request","url","Emitter","_query","_header","err","res","Error","parse","original","new_err","request","end","getXHR","XMLHttpRequest","protocol","ActiveXObject","serializeObject","types","json","xml","urlencoded","form","form-data","application/x-www-form-urlencoded","application/json","get","ct","statusType","info","ok","clientError","serverError","error","toError","accepted","noContent","badRequest","unauthorized","notAcceptable","notFound","forbidden","msg","use","timeout","ms","_timeout","clearTimeout","_timer","abort","aborted","set","unset","getHeader","accept","auth","user","pass","btoa","query","_formData","FormData","append","attach","file","filename","send","_data","_callback","crossDomainError","crossDomain","timeoutError","withCredentials","_withCredentials","onreadystatechange","readyState","timedout","handleProgress","total","percent","hasListeners","onprogress","upload","setTimeout","setRequestHeader","del","patch","post","put","_callbacks","once","removeListener","removeAllListeners","listeners","initial","idx","curr"],"mappings":"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","file":"vendor.bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// install a JSONP callback for chunk loading\n/******/ \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n/******/ \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n/******/ \t\t// add \"moreModules\" to the modules object,\n/******/ \t\t// then flag all \"chunkIds\" as loaded and fire callback\n/******/ \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n/******/ \t\tfor(;i < chunkIds.length; i++) {\n/******/ \t\t\tchunkId = chunkIds[i];\n/******/ \t\t\tif(installedChunks[chunkId])\n/******/ \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n/******/ \t\t\tinstalledChunks[chunkId] = 0;\n/******/ \t\t}\n/******/ \t\tfor(moduleId in moreModules) {\n/******/ \t\t\tmodules[moduleId] = moreModules[moduleId];\n/******/ \t\t}\n/******/ \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n/******/ \t\twhile(callbacks.length)\n/******/ \t\t\tcallbacks.shift().call(null, __webpack_require__);\n/******/ \t\tif(moreModules[0]) {\n/******/ \t\t\tinstalledModules[0] = 0;\n/******/ \t\t\treturn __webpack_require__(0);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// object to store loaded and loading chunks\n/******/ \t// \"0\" means \"already loaded\"\n/******/ \t// Array means \"loading\", array contains callbacks\n/******/ \tvar installedChunks = {\n/******/ \t\t0:0\n/******/ \t};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/ \t// This file contains only the entry chunk.\n/******/ \t// The chunk loading function for additional chunks\n/******/ \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n/******/ \t\t// \"0\" is the signal for \"already loaded\"\n/******/ \t\tif(installedChunks[chunkId] === 0)\n/******/ \t\t\treturn callback.call(null, __webpack_require__);\n/******/\n/******/ \t\t// an array means \"currently loading\".\n/******/ \t\tif(installedChunks[chunkId] !== undefined) {\n/******/ \t\t\tinstalledChunks[chunkId].push(callback);\n/******/ \t\t} else {\n/******/ \t\t\t// start chunk loading\n/******/ \t\t\tinstalledChunks[chunkId] = [callback];\n/******/ \t\t\tvar head = document.getElementsByTagName('head')[0];\n/******/ \t\t\tvar script = document.createElement('script');\n/******/ \t\t\tscript.type = 'text/javascript';\n/******/ \t\t\tscript.charset = 'utf-8';\n/******/ \t\t\tscript.async = true;\n/******/\n/******/ \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".bundle.js\";\n/******/ \t\t\thead.appendChild(script);\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/*!******************************!*\\\n  !*** ./static/src/vendor.js ***!\n  \\******************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(/*! riot */ 1);\n\t\n\t__webpack_require__(/*! superagent/lib/client */ 2);\n\n/***/ },\n/* 1 */\n/*!************************!*\\\n  !*** ./~/riot/riot.js ***!\n  \\************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* Riot v2.1.0, @license MIT, (c) 2015 Muut Inc. + contributors */\n\t\n\t;(function(window) {\n\t  // 'use strict' does not allow us to override the events properties https://github.com/muut/riotjs/blob/dev/lib/tag/update.js#L7-L10\n\t  // it leads to the following error on firefox \"setting a property that has only a getter\"\n\t  //'use strict'\n\t\n\t\n\t  var riot = { version: 'v2.1.0', settings: {} }\n\t\n\t\n\triot.observable = function(el) {\n\t\n\t  el = el || {}\n\t\n\t  var callbacks = {},\n\t      _id = 0\n\t\n\t  el.on = function(events, fn) {\n\t    if (typeof fn == 'function') {\n\t      fn._id = typeof fn._id == 'undefined' ? _id++ : fn._id\n\t\n\t      events.replace(/\\S+/g, function(name, pos) {\n\t        (callbacks[name] = callbacks[name] || []).push(fn)\n\t        fn.typed = pos > 0\n\t      })\n\t    }\n\t    return el\n\t  }\n\t\n\t  el.off = function(events, fn) {\n\t    if (events == '*') callbacks = {}\n\t    else {\n\t      events.replace(/\\S+/g, function(name) {\n\t        if (fn) {\n\t          var arr = callbacks[name]\n\t          for (var i = 0, cb; (cb = arr && arr[i]); ++i) {\n\t            if (cb._id == fn._id) { arr.splice(i, 1); i-- }\n\t          }\n\t        } else {\n\t          callbacks[name] = []\n\t        }\n\t      })\n\t    }\n\t    return el\n\t  }\n\t\n\t  // only single event supported\n\t  el.one = function(name, fn) {\n\t    function on() {\n\t      el.off(name, on)\n\t      fn.apply(el, arguments)\n\t    }\n\t    return el.on(name, on)\n\t  }\n\t\n\t  el.trigger = function(name) {\n\t    var args = [].slice.call(arguments, 1),\n\t        fns = callbacks[name] || []\n\t\n\t    for (var i = 0, fn; (fn = fns[i]); ++i) {\n\t      if (!fn.busy) {\n\t        fn.busy = 1\n\t        fn.apply(el, fn.typed ? [name].concat(args) : args)\n\t        if (fns[i] !== fn) { i-- }\n\t        fn.busy = 0\n\t      }\n\t    }\n\t\n\t    if (callbacks.all && name != 'all') {\n\t      el.trigger.apply(el, ['all', name].concat(args))\n\t    }\n\t\n\t    return el\n\t  }\n\t\n\t  return el\n\t\n\t}\n\triot.mixin = (function() {\n\t  var registeredMixins = {}\n\t  return function(name, mixin) {\n\t    if (!mixin) return registeredMixins[name]\n\t      else registeredMixins[name] = mixin\n\t  }\n\t})()\n\t\n\t;(function(riot, evt, window) {\n\t\n\t  // browsers only\n\t  if (!window) return\n\t\n\t  var loc = window.location,\n\t      fns = riot.observable(),\n\t      win = window,\n\t      started = false,\n\t      current\n\t\n\t  function hash() {\n\t    return loc.href.split('#')[1] || ''\n\t  }\n\t\n\t  function parser(path) {\n\t    return path.split('/')\n\t  }\n\t\n\t  function emit(path) {\n\t    if (path.type) path = hash()\n\t\n\t    if (path != current) {\n\t      fns.trigger.apply(null, ['H'].concat(parser(path)))\n\t      current = path\n\t    }\n\t  }\n\t\n\t  var r = riot.route = function(arg) {\n\t    // string\n\t    if (arg[0]) {\n\t      loc.hash = arg\n\t      emit(arg)\n\t\n\t    // function\n\t    } else {\n\t      fns.on('H', arg)\n\t    }\n\t  }\n\t\n\t  r.exec = function(fn) {\n\t    fn.apply(null, parser(hash()))\n\t  }\n\t\n\t  r.parser = function(fn) {\n\t    parser = fn\n\t  }\n\t\n\t  r.stop = function () {\n\t    if (!started) return\n\t    win.removeEventListener ? win.removeEventListener(evt, emit, false) : win.detachEvent('on' + evt, emit)\n\t    fns.off('*')\n\t    started = false\n\t  }\n\t\n\t  r.start = function () {\n\t    if (started) return\n\t    win.addEventListener ? win.addEventListener(evt, emit, false) : win.attachEvent('on' + evt, emit)\n\t    started = true\n\t  }\n\t\n\t  // autostart the router\n\t  r.start()\n\t\n\t})(riot, 'hashchange', window)\n\t/*\n\t\n\t//// How it works?\n\t\n\t\n\tThree ways:\n\t\n\t1. Expressions: tmpl('{ value }', data).\n\t   Returns the result of evaluated expression as a raw object.\n\t\n\t2. Templates: tmpl('Hi { name } { surname }', data).\n\t   Returns a string with evaluated expressions.\n\t\n\t3. Filters: tmpl('{ show: !done, highlight: active }', data).\n\t   Returns a space separated list of trueish keys (mainly\n\t   used for setting html classes), e.g. \"show highlight\".\n\t\n\t\n\t// Template examples\n\t\n\ttmpl('{ title || \"Untitled\" }', data)\n\ttmpl('Results are { results ? \"ready\" : \"loading\" }', data)\n\ttmpl('Today is { new Date() }', data)\n\ttmpl('{ message.length > 140 && \"Message is too long\" }', data)\n\ttmpl('This item got { Math.round(rating) } stars', data)\n\ttmpl('<h1>{ title }</h1>{ body }', data)\n\t\n\t\n\t// Falsy expressions in templates\n\t\n\tIn templates (as opposed to single expressions) all falsy values\n\texcept zero (undefined/null/false) will default to empty string:\n\t\n\ttmpl('{ undefined } - { false } - { null } - { 0 }', {})\n\t// will return: \" - - - 0\"\n\t\n\t*/\n\t\n\t\n\tvar brackets = (function(orig, s, b) {\n\t  return function(x) {\n\t\n\t    // make sure we use the current setting\n\t    s = riot.settings.brackets || orig\n\t    if (b != s) b = s.split(' ')\n\t\n\t    // if regexp given, rewrite it with current brackets (only if differ from default)\n\t    return x && x.test\n\t      ? s == orig\n\t        ? x : RegExp(x.source\n\t                      .replace(/\\{/g, b[0].replace(/(?=.)/g, '\\\\'))\n\t                      .replace(/\\}/g, b[1].replace(/(?=.)/g, '\\\\')),\n\t                    x.global ? 'g' : '')\n\t\n\t      // else, get specific bracket\n\t      : b[x]\n\t\n\t  }\n\t})('{ }')\n\t\n\t\n\tvar tmpl = (function() {\n\t\n\t  var cache = {},\n\t      reVars = /(['\"\\/]).*?[^\\\\]\\1|\\.\\w*|\\w*:|\\b(?:(?:new|typeof|in|instanceof) |(?:this|true|false|null|undefined)\\b|function *\\()|([a-z_$]\\w*)/gi\n\t              // [ 1               ][ 2  ][ 3 ][ 4                                                                                  ][ 5       ]\n\t              // find variable names:\n\t              // 1. skip quoted strings and regexps: \"a b\", 'a b', 'a \\'b\\'', /a b/\n\t              // 2. skip object properties: .name\n\t              // 3. skip object literals: name:\n\t              // 4. skip javascript keywords\n\t              // 5. match var name\n\t\n\t  // build a template (or get it from cache), render with data\n\t  return function(str, data) {\n\t    return str && (cache[str] = cache[str] || tmpl(str))(data)\n\t  }\n\t\n\t\n\t  // create a template instance\n\t\n\t  function tmpl(s, p) {\n\t\n\t    // default template string to {}\n\t    s = (s || (brackets(0) + brackets(1)))\n\t\n\t      // temporarily convert \\{ and \\} to a non-character\n\t      .replace(brackets(/\\\\{/g), '\\uFFF0')\n\t      .replace(brackets(/\\\\}/g), '\\uFFF1')\n\t\n\t    // split string to expression and non-expresion parts\n\t    p = split(s, extract(s, brackets(/{/), brackets(/}/)))\n\t\n\t    return new Function('d', 'return ' + (\n\t\n\t      // is it a single expression or a template? i.e. {x} or <b>{x}</b>\n\t      !p[0] && !p[2] && !p[3]\n\t\n\t        // if expression, evaluate it\n\t        ? expr(p[1])\n\t\n\t        // if template, evaluate all expressions in it\n\t        : '[' + p.map(function(s, i) {\n\t\n\t            // is it an expression or a string (every second part is an expression)\n\t          return i % 2\n\t\n\t              // evaluate the expressions\n\t              ? expr(s, true)\n\t\n\t              // process string parts of the template:\n\t              : '\"' + s\n\t\n\t                  // preserve new lines\n\t                  .replace(/\\n/g, '\\\\n')\n\t\n\t                  // escape quotes\n\t                  .replace(/\"/g, '\\\\\"')\n\t\n\t                + '\"'\n\t\n\t        }).join(',') + '].join(\"\")'\n\t      )\n\t\n\t      // bring escaped { and } back\n\t      .replace(/\\uFFF0/g, brackets(0))\n\t      .replace(/\\uFFF1/g, brackets(1))\n\t\n\t    + ';')\n\t\n\t  }\n\t\n\t\n\t  // parse { ... } expression\n\t\n\t  function expr(s, n) {\n\t    s = s\n\t\n\t      // convert new lines to spaces\n\t      .replace(/\\n/g, ' ')\n\t\n\t      // trim whitespace, brackets, strip comments\n\t      .replace(brackets(/^[{ ]+|[ }]+$|\\/\\*.+?\\*\\//g), '')\n\t\n\t    // is it an object literal? i.e. { key : value }\n\t    return /^\\s*[\\w- \"']+ *:/.test(s)\n\t\n\t      // if object literal, return trueish keys\n\t      // e.g.: { show: isOpen(), done: item.done } -> \"show done\"\n\t      ? '[' +\n\t\n\t          // extract key:val pairs, ignoring any nested objects\n\t          extract(s,\n\t\n\t              // name part: name:, \"name\":, 'name':, name :\n\t              /[\"' ]*[\\w- ]+[\"' ]*:/,\n\t\n\t              // expression part: everything upto a comma followed by a name (see above) or end of line\n\t              /,(?=[\"' ]*[\\w- ]+[\"' ]*:)|}|$/\n\t              ).map(function(pair) {\n\t\n\t                // get key, val parts\n\t                return pair.replace(/^[ \"']*(.+?)[ \"']*: *(.+?),? *$/, function(_, k, v) {\n\t\n\t                  // wrap all conditional parts to ignore errors\n\t                  return v.replace(/[^&|=!><]+/g, wrap) + '?\"' + k + '\":\"\",'\n\t\n\t                })\n\t\n\t              }).join('')\n\t\n\t        + '].join(\" \").trim()'\n\t\n\t      // if js expression, evaluate as javascript\n\t      : wrap(s, n)\n\t\n\t  }\n\t\n\t\n\t  // execute js w/o breaking on errors or undefined vars\n\t\n\t  function wrap(s, nonull) {\n\t    s = s.trim()\n\t    return !s ? '' : '(function(v){try{v='\n\t\n\t        // prefix vars (name => data.name)\n\t        + (s.replace(reVars, function(s, _, v) { return v ? '(d.'+v+'===undefined?'+(typeof window == 'undefined' ? 'global.' : 'window.')+v+':d.'+v+')' : s })\n\t\n\t          // break the expression if its empty (resulting in undefined value)\n\t          || 'x')\n\t      + '}catch(e){'\n\t      + '}finally{return '\n\t\n\t        // default to empty string for falsy values except zero\n\t        + (nonull === true ? '!v&&v!==0?\"\":v' : 'v')\n\t\n\t      + '}}).call(d)'\n\t  }\n\t\n\t\n\t  // split string by an array of substrings\n\t\n\t  function split(str, substrings) {\n\t    var parts = []\n\t    substrings.map(function(sub, i) {\n\t\n\t      // push matched expression and part before it\n\t      i = str.indexOf(sub)\n\t      parts.push(str.slice(0, i), sub)\n\t      str = str.slice(i + sub.length)\n\t    })\n\t\n\t    // push the remaining part\n\t    return parts.concat(str)\n\t  }\n\t\n\t\n\t  // match strings between opening and closing regexp, skipping any inner/nested matches\n\t\n\t  function extract(str, open, close) {\n\t\n\t    var start,\n\t        level = 0,\n\t        matches = [],\n\t        re = new RegExp('('+open.source+')|('+close.source+')', 'g')\n\t\n\t    str.replace(re, function(_, open, close, pos) {\n\t\n\t      // if outer inner bracket, mark position\n\t      if(!level && open) start = pos\n\t\n\t      // in(de)crease bracket level\n\t      level += open ? 1 : -1\n\t\n\t      // if outer closing bracket, grab the match\n\t      if(!level && close != null) matches.push(str.slice(start, pos+close.length))\n\t\n\t    })\n\t\n\t    return matches\n\t  }\n\t\n\t})()\n\t\n\t// { key, i in items} -> { key, i, items }\n\tfunction loopKeys(expr) {\n\t  var ret = { val: expr },\n\t      els = expr.split(/\\s+in\\s+/)\n\t\n\t  if (els[1]) {\n\t    ret.val = brackets(0) + els[1]\n\t    els = els[0].slice(brackets(0).length).trim().split(/,\\s*/)\n\t    ret.key = els[0]\n\t    ret.pos = els[1]\n\t  }\n\t\n\t  return ret\n\t}\n\t\n\tfunction mkitem(expr, key, val) {\n\t  var item = {}\n\t  item[expr.key] = key\n\t  if (expr.pos) item[expr.pos] = val\n\t  return item\n\t}\n\t\n\t\n\t/* Beware: heavy stuff */\n\tfunction _each(dom, parent, expr) {\n\t\n\t  remAttr(dom, 'each')\n\t\n\t  var template = dom.outerHTML,\n\t      prev = dom.previousSibling,\n\t      root = dom.parentNode,\n\t      rendered = [],\n\t      tags = [],\n\t      checksum\n\t\n\t  expr = loopKeys(expr)\n\t\n\t  function add(pos, item, tag) {\n\t    rendered.splice(pos, 0, item)\n\t    tags.splice(pos, 0, tag)\n\t  }\n\t\n\t  // clean template code\n\t  parent.one('update', function() {\n\t    root.removeChild(dom)\n\t\n\t  }).one('premount', function() {\n\t    if (root.stub) root = parent.root\n\t\n\t  }).on('update', function() {\n\t\n\t    var items = tmpl(expr.val, parent)\n\t    if (!items) return\n\t\n\t    // object loop. any changes cause full redraw\n\t    if (!Array.isArray(items)) {\n\t      var testsum = JSON.stringify(items)\n\t\n\t      if (testsum == checksum) return\n\t      checksum = testsum\n\t\n\t      // clear old items\n\t      each(tags, function(tag) { tag.unmount() })\n\t      rendered = []\n\t      tags = []\n\t\n\t      items = Object.keys(items).map(function(key) {\n\t        return mkitem(expr, key, items[key])\n\t      })\n\t\n\t    }\n\t\n\t    // unmount redundant\n\t    each(rendered, function(item) {\n\t      if (item instanceof Object) {\n\t        // skip existing items\n\t        if (items.indexOf(item) > -1) {\n\t          return\n\t        }\n\t      } else {\n\t        // find all non-objects\n\t        var newItems = arrFindEquals(items, item),\n\t            oldItems = arrFindEquals(rendered, item)\n\t\n\t        // if more or equal amount, no need to remove\n\t        if (newItems.length >= oldItems.length) {\n\t          return\n\t        }\n\t      }\n\t      var pos = rendered.indexOf(item),\n\t          tag = tags[pos]\n\t\n\t      if (tag) {\n\t        tag.unmount()\n\t        rendered.splice(pos, 1)\n\t        tags.splice(pos, 1)\n\t        // to let \"each\" know that this item is removed\n\t        return false\n\t      }\n\t\n\t    })\n\t\n\t    // mount new / reorder\n\t    var prevBase = [].indexOf.call(root.childNodes, prev) + 1\n\t    each(items, function(item, i) {\n\t\n\t      // start index search from position based on the current i\n\t      var pos = items.indexOf(item, i),\n\t          oldPos = rendered.indexOf(item, i)\n\t\n\t      // if not found, search backwards from current i position\n\t      pos < 0 && (pos = items.lastIndexOf(item, i))\n\t      oldPos < 0 && (oldPos = rendered.lastIndexOf(item, i))\n\t\n\t      if (!(item instanceof Object)) {\n\t        // find all non-objects\n\t        var newItems = arrFindEquals(items, item),\n\t            oldItems = arrFindEquals(rendered, item)\n\t\n\t        // if more, should mount one new\n\t        if (newItems.length > oldItems.length) {\n\t          oldPos = -1\n\t        }\n\t      }\n\t\n\t      // mount new\n\t      var nodes = root.childNodes\n\t      if (oldPos < 0) {\n\t        if (!checksum && expr.key) var _item = mkitem(expr, item, pos)\n\t\n\t        var tag = new Tag({ tmpl: template }, {\n\t          before: nodes[prevBase + pos],\n\t          parent: parent,\n\t          root: root,\n\t          item: _item || item\n\t        })\n\t\n\t        tag.mount()\n\t\n\t        add(pos, item, tag)\n\t        return true\n\t      }\n\t\n\t      // change pos value\n\t      if (expr.pos && tags[oldPos][expr.pos] != pos) {\n\t        tags[oldPos].one('update', function(item) {\n\t          item[expr.pos] = pos\n\t        })\n\t        tags[oldPos].update()\n\t      }\n\t\n\t      // reorder\n\t      if (pos != oldPos) {\n\t        root.insertBefore(nodes[prevBase + oldPos], nodes[prevBase + (pos > oldPos ? pos + 1 : pos)])\n\t        return add(pos, rendered.splice(oldPos, 1)[0], tags.splice(oldPos, 1)[0])\n\t      }\n\t\n\t    })\n\t\n\t    rendered = items.slice()\n\t\n\t  }).one('updated', function() {\n\t    walk(root, function(dom) {\n\t      each(dom.attributes, function(attr) {\n\t        if (/^(name|id)$/.test(attr.name)) parent[attr.value] = dom\n\t      })\n\t    })\n\t  })\n\t\n\t}\n\t\n\t\n\tfunction parseNamedElements(root, parent, childTags) {\n\t\n\t  walk(root, function(dom) {\n\t    if (dom.nodeType == 1) {\n\t      dom.isLoop = 0\n\t      if(dom.parentNode && dom.parentNode.isLoop) dom.isLoop = 1\n\t      if(dom.getAttribute('each')) dom.isLoop = 1\n\t      // custom child tag\n\t      var child = getTag(dom)\n\t\n\t      if (child && !dom.isLoop) {\n\t        var tag = new Tag(child, { root: dom, parent: parent }, dom.innerHTML),\n\t            namedTag = dom.getAttribute('name'),\n\t            tagName = namedTag && namedTag.indexOf(brackets(0)) < 0 ? namedTag : child.name,\n\t            ptag = parent,\n\t            cachedTag\n\t\n\t        while(!getTag(ptag.root)) {\n\t          if(!ptag.parent) break\n\t          ptag = ptag.parent\n\t        }\n\t        // fix for the parent attribute in the looped elements\n\t        tag.parent = ptag\n\t\n\t        cachedTag = ptag.tags[tagName]\n\t\n\t        // if there are multiple children tags having the same name\n\t        if (cachedTag) {\n\t          // if the parent tags property is not yet an array\n\t          // create it adding the first cached tag\n\t          if (!Array.isArray(cachedTag))\n\t            ptag.tags[tagName] = [cachedTag]\n\t          // add the new nested tag to the array\n\t          ptag.tags[tagName].push(tag)\n\t        } else {\n\t          ptag.tags[tagName] = tag\n\t        }\n\t\n\t        // empty the child node once we got its template\n\t        // to avoid that its children get compiled multiple times\n\t        dom.innerHTML = ''\n\t        childTags.push(tag)\n\t      }\n\t\n\t      if(!dom.isLoop)\n\t        each(dom.attributes, function(attr) {\n\t          if (/^(name|id)$/.test(attr.name)) parent[attr.value] = dom\n\t        })\n\t    }\n\t\n\t  })\n\t\n\t}\n\t\n\tfunction parseExpressions(root, tag, expressions) {\n\t\n\t  function addExpr(dom, val, extra) {\n\t    if (val.indexOf(brackets(0)) >= 0) {\n\t      var expr = { dom: dom, expr: val }\n\t      expressions.push(extend(expr, extra))\n\t    }\n\t  }\n\t\n\t  walk(root, function(dom) {\n\t    var type = dom.nodeType\n\t\n\t    // text node\n\t    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n\t    if (type != 1) return\n\t\n\t    /* element */\n\t\n\t    // loop\n\t    var attr = dom.getAttribute('each')\n\t    if (attr) { _each(dom, tag, attr); return false }\n\t\n\t    // attribute expressions\n\t    each(dom.attributes, function(attr) {\n\t      var name = attr.name,\n\t        bool = name.split('__')[1]\n\t\n\t      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n\t      if (bool) { remAttr(dom, name); return false }\n\t\n\t    })\n\t\n\t    // skip custom tags\n\t    if (getTag(dom)) return false\n\t\n\t  })\n\t\n\t}\n\tfunction Tag(impl, conf, innerHTML) {\n\t\n\t  var self = riot.observable(this),\n\t      opts = inherit(conf.opts) || {},\n\t      dom = mkdom(impl.tmpl),\n\t      parent = conf.parent,\n\t      expressions = [],\n\t      childTags = [],\n\t      root = conf.root,\n\t      item = conf.item,\n\t      fn = impl.fn,\n\t      tagName = root.tagName.toLowerCase(),\n\t      attr = {},\n\t      loopDom,\n\t      TAG_ATTRIBUTES = /([\\w\\-]+)\\s?=\\s?['\"]([^'\"]+)[\"']/gim\n\t\n\t  if (fn && root._tag) {\n\t    root._tag.unmount(true)\n\t  }\n\t\n\t  if(impl.attrs) {\n\t    var attrs = impl.attrs.match(TAG_ATTRIBUTES)\n\t\n\t    each(attrs, function(a) {\n\t      var kv = a.split(/\\s?=\\s?/)\n\t      root.setAttribute(kv[0], kv[1].replace(/['\"]/g, ''))\n\t    })\n\t\n\t  }\n\t  // keep a reference to the tag just created\n\t  // so we will be able to mount this tag multiple times\n\t  root._tag = this\n\t\n\t  // create a unique id to this tag\n\t  // it could be handy to use it also to improve the virtual dom rendering speed\n\t  this._id = fastAbs(~~(new Date().getTime() * Math.random()))\n\t\n\t  extend(this, { parent: parent, root: root, opts: opts, tags: {} }, item)\n\t\n\t  // grab attributes\n\t  each(root.attributes, function(el) {\n\t    attr[el.name] = el.value\n\t  })\n\t\n\t\n\t  if (dom.innerHTML && !/select/.test(tagName) && !/tbody/.test(tagName) && !/tr/.test(tagName))\n\t    // replace all the yield tags with the tag inner html\n\t    dom.innerHTML = replaceYield(dom.innerHTML, innerHTML)\n\t\n\t\n\t  // options\n\t  function updateOpts() {\n\t    each(Object.keys(attr), function(name) {\n\t      opts[name] = tmpl(attr[name], parent || self)\n\t    })\n\t  }\n\t\n\t  this.update = function(data, init) {\n\t    extend(self, data, item)\n\t    updateOpts()\n\t    self.trigger('update', item)\n\t    update(expressions, self, item)\n\t    self.trigger('updated')\n\t  }\n\t\n\t  this.mixin = function() {\n\t    each(arguments, function(mix) {\n\t      mix = 'string' == typeof mix ? riot.mixin(mix) : mix\n\t      each(Object.keys(mix), function(key) {\n\t        // bind methods to self\n\t        if ('init' != key)\n\t          self[key] = 'function' == typeof mix[key] ? mix[key].bind(self) : mix[key]\n\t      })\n\t      // init method will be called automatically\n\t      if (mix.init) mix.init.bind(self)()\n\t    })\n\t  }\n\t\n\t  this.mount = function() {\n\t\n\t    updateOpts()\n\t\n\t    // initialiation\n\t    fn && fn.call(self, opts)\n\t\n\t    toggle(true)\n\t\n\t    // parse layout after init. fn may calculate args for nested custom tags\n\t    parseExpressions(dom, self, expressions)\n\t\n\t    if (!self.parent) self.update()\n\t\n\t    // internal use only, fixes #403\n\t    self.trigger('premount')\n\t\n\t    if (fn) {\n\t      while (dom.firstChild) root.appendChild(dom.firstChild)\n\t\n\t    } else {\n\t      loopDom = dom.firstChild\n\t      root.insertBefore(loopDom, conf.before || null) // null needed for IE8\n\t    }\n\t\n\t    if (root.stub) self.root = root = parent.root\n\t\n\t    // if it's not a child tag we can trigger its mount event\n\t    if (!self.parent) self.trigger('mount')\n\t    // otherwise we need to wait that the parent event gets triggered\n\t    else self.parent.one('mount', function() { self.trigger('mount') })\n\t  }\n\t\n\t\n\t  this.unmount = function(keepRootTag) {\n\t    var el = fn ? root : loopDom,\n\t        p = el.parentNode\n\t\n\t    if (p) {\n\t\n\t      if (parent) {\n\t        // remove this tag from the parent tags object\n\t        // if there are multiple nested tags with same name..\n\t        // remove this element form the array\n\t        if (Array.isArray(parent.tags[tagName])) {\n\t          each(parent.tags[tagName], function(tag, i) {\n\t            if (tag._id == self._id)\n\t              parent.tags[tagName].splice(i, 1)\n\t          })\n\t        } else\n\t          // otherwise just delete the tag instance\n\t          parent.tags[tagName] = undefined\n\t      } else {\n\t        while (el.firstChild) el.removeChild(el.firstChild)\n\t      }\n\t\n\t      if (!keepRootTag)\n\t        p.removeChild(el)\n\t\n\t    }\n\t\n\t\n\t    self.trigger('unmount')\n\t    toggle()\n\t    self.off('*')\n\t    // somehow ie8 does not like `delete root._tag`\n\t    root._tag = null\n\t\n\t  }\n\t\n\t  function toggle(isMount) {\n\t\n\t    // mount/unmount children\n\t    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })\n\t\n\t    // listen/unlisten parent (events flow one way from parent to children)\n\t    if (parent) {\n\t      var evt = isMount ? 'on' : 'off'\n\t      parent[evt]('update', self.update)[evt]('unmount', self.unmount)\n\t    }\n\t  }\n\t\n\t  // named elements available for fn\n\t  parseNamedElements(dom, this, childTags)\n\t\n\t\n\t}\n\t\n\tfunction setEventHandler(name, handler, dom, tag, item) {\n\t\n\t  dom[name] = function(e) {\n\t\n\t    // cross browser event fix\n\t    e = e || window.event\n\t    e.which = e.which || e.charCode || e.keyCode\n\t    e.target = e.target || e.srcElement\n\t    e.currentTarget = dom\n\t    e.item = item\n\t\n\t    // prevent default behaviour (by default)\n\t    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n\t      e.preventDefault && e.preventDefault()\n\t      e.returnValue = false\n\t    }\n\t\n\t    if (!e.preventUpdate) {\n\t      var el = item ? tag.parent : tag\n\t      el.update()\n\t    }\n\t\n\t  }\n\t\n\t}\n\t\n\t// used by if- attribute\n\tfunction insertTo(root, node, before) {\n\t  if (root) {\n\t    root.insertBefore(before, node)\n\t    root.removeChild(node)\n\t  }\n\t}\n\t\n\t// item = currently looped item\n\tfunction update(expressions, tag, item) {\n\t\n\t  each(expressions, function(expr, i) {\n\t\n\t    var dom = expr.dom,\n\t        attrName = expr.attr,\n\t        value = tmpl(expr.expr, tag),\n\t        parent = expr.dom.parentNode\n\t\n\t    if (value == null) value = ''\n\t\n\t    // leave out riot- prefixes from strings inside textarea\n\t    if (parent && parent.tagName == 'TEXTAREA') value = value.replace(/riot-/g, '')\n\t\n\t    // no change\n\t    if (expr.value === value) return\n\t    expr.value = value\n\t\n\t    // text node\n\t    if (!attrName) return dom.nodeValue = value.toString()\n\t\n\t    // remove original attribute\n\t    remAttr(dom, attrName)\n\t\n\t    // event handler\n\t    if (typeof value == 'function') {\n\t      setEventHandler(attrName, value, dom, tag, item)\n\t\n\t    // if- conditional\n\t    } else if (attrName == 'if') {\n\t      var stub = expr.stub\n\t\n\t      // add to DOM\n\t      if (value) {\n\t        stub && insertTo(stub.parentNode, stub, dom)\n\t\n\t      // remove from DOM\n\t      } else {\n\t        stub = expr.stub = stub || document.createTextNode('')\n\t        insertTo(dom.parentNode, dom, stub)\n\t      }\n\t\n\t    // show / hide\n\t    } else if (/^(show|hide)$/.test(attrName)) {\n\t      if (attrName == 'hide') value = !value\n\t      dom.style.display = value ? '' : 'none'\n\t\n\t    // field value\n\t    } else if (attrName == 'value') {\n\t      dom.value = value\n\t\n\t    // <img src=\"{ expr }\">\n\t    } else if (attrName.slice(0, 5) == 'riot-') {\n\t      attrName = attrName.slice(5)\n\t      value ? dom.setAttribute(attrName, value) : remAttr(dom, attrName)\n\t\n\t    } else {\n\t      if (expr.bool) {\n\t        dom[attrName] = value\n\t        if (!value) return\n\t        value = attrName\n\t      }\n\t\n\t      if (typeof value != 'object') dom.setAttribute(attrName, value)\n\t\n\t    }\n\t\n\t  })\n\t\n\t}\n\t\n\tfunction each(els, fn) {\n\t  for (var i = 0, len = (els || []).length, el; i < len; i++) {\n\t    el = els[i]\n\t    // return false -> remove current item during loop\n\t    if (el != null && fn(el, i) === false) i--\n\t  }\n\t  return els\n\t}\n\t\n\tfunction remAttr(dom, name) {\n\t  dom.removeAttribute(name)\n\t}\n\t\n\tfunction fastAbs(nr) {\n\t  return (nr ^ (nr >> 31)) - (nr >> 31)\n\t}\n\t\n\t// max 2 from objects allowed\n\tfunction extend(obj, from, from2) {\n\t  from && each(Object.keys(from), function(key) {\n\t    obj[key] = from[key]\n\t  })\n\t  return from2 ? extend(obj, from2) : obj\n\t}\n\t\n\tfunction checkIE() {\n\t  if (window) {\n\t    var ua = navigator.userAgent\n\t    var msie = ua.indexOf('MSIE ')\n\t    if (msie > 0) {\n\t      return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10)\n\t    }\n\t    else {\n\t      return 0\n\t    }\n\t  }\n\t}\n\t\n\tfunction optionInnerHTML(el, html) {\n\t  var opt = document.createElement('option'),\n\t      valRegx = /value=[\\\"'](.+?)[\\\"']/,\n\t      selRegx = /selected=[\\\"'](.+?)[\\\"']/,\n\t      valuesMatch = html.match(valRegx),\n\t      selectedMatch = html.match(selRegx)\n\t\n\t  opt.innerHTML = html\n\t\n\t  if (valuesMatch) {\n\t    opt.value = valuesMatch[1]\n\t  }\n\t\n\t  if (selectedMatch) {\n\t    opt.setAttribute('riot-selected', selectedMatch[1])\n\t  }\n\t\n\t  el.appendChild(opt)\n\t}\n\t\n\tfunction tbodyInnerHTML(el, html, tagName) {\n\t  var div = document.createElement('div')\n\t  div.innerHTML = '<table>' + html + '</table>'\n\t\n\t  if (/td|th/.test(tagName)) {\n\t    el.appendChild(div.firstChild.firstChild.firstChild.firstChild)\n\t  } else {\n\t    el.appendChild(div.firstChild.firstChild.firstChild)\n\t  }\n\t}\n\t\n\tfunction mkdom(template) {\n\t  var tagName = template.trim().slice(1, 3).toLowerCase(),\n\t      rootTag = /td|th/.test(tagName) ? 'tr' : tagName == 'tr' ? 'tbody' : 'div',\n\t      el = mkEl(rootTag)\n\t\n\t  el.stub = true\n\t\n\t  if (tagName === 'op' && ieVersion && ieVersion < 10) {\n\t    optionInnerHTML(el, template)\n\t  } else if ((rootTag === 'tbody' || rootTag === 'tr') && ieVersion && ieVersion < 10) {\n\t    tbodyInnerHTML(el, template, tagName)\n\t  } else\n\t    el.innerHTML = template\n\t\n\t  return el\n\t}\n\t\n\tfunction walk(dom, fn) {\n\t  if (dom) {\n\t    if (fn(dom) === false) walk(dom.nextSibling, fn)\n\t    else {\n\t      dom = dom.firstChild\n\t\n\t      while (dom) {\n\t        walk(dom, fn)\n\t        dom = dom.nextSibling\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction mkEl(name) {\n\t  return document.createElement(name)\n\t}\n\t\n\tfunction replaceYield (tmpl, innerHTML) {\n\t  return tmpl.replace(/<(yield)\\/?>(<\\/\\1>)?/gim, innerHTML || '')\n\t}\n\t\n\tfunction $$(selector, ctx) {\n\t  ctx = ctx || document\n\t  return ctx.querySelectorAll(selector)\n\t}\n\t\n\tfunction arrDiff(arr1, arr2) {\n\t  return arr1.filter(function(el) {\n\t    return arr2.indexOf(el) < 0\n\t  })\n\t}\n\t\n\tfunction arrFindEquals(arr, el) {\n\t  return arr.filter(function (_el) {\n\t    return _el === el\n\t  })\n\t}\n\t\n\tfunction inherit(parent) {\n\t  function Child() {}\n\t  Child.prototype = parent\n\t  return new Child()\n\t}\n\t/**\n\t *\n\t * Hacks needed for the old internet explorer versions [lower than IE10]\n\t *\n\t */\n\t\n\tvar ieVersion = checkIE()\n\t\n\tfunction checkIE() {\n\t  if (window) {\n\t    var ua = navigator.userAgent\n\t    var msie = ua.indexOf('MSIE ')\n\t    if (msie > 0) {\n\t      return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10)\n\t    }\n\t    else {\n\t      return 0\n\t    }\n\t  }\n\t}\n\t\n\tfunction tbodyInnerHTML(el, html, tagName) {\n\t  var div = mkEl('div'),\n\t      loops = /td|th/.test(tagName) ? 3 : 2,\n\t      child\n\t\n\t  div.innerHTML = '<table>' + html + '</table>'\n\t  child = div.firstChild\n\t\n\t  while(loops--) {\n\t    child = child.firstChild\n\t  }\n\t\n\t  el.appendChild(child)\n\t\n\t}\n\t\n\tfunction optionInnerHTML(el, html) {\n\t  var opt = mkEl('option'),\n\t      valRegx = /value=[\\\"'](.+?)[\\\"']/,\n\t      selRegx = /selected=[\\\"'](.+?)[\\\"']/,\n\t      valuesMatch = html.match(valRegx),\n\t      selectedMatch = html.match(selRegx)\n\t\n\t  opt.innerHTML = html\n\t\n\t  if (valuesMatch) {\n\t    opt.value = valuesMatch[1]\n\t  }\n\t\n\t  if (selectedMatch) {\n\t    opt.setAttribute('riot-selected', selectedMatch[1])\n\t  }\n\t\n\t  el.appendChild(opt)\n\t}\n\t\n\t/*\n\t Virtual dom is an array of custom tags on the document.\n\t Updates and unmounts propagate downwards from parent to children.\n\t*/\n\t\n\tvar virtualDom = [],\n\t    tagImpl = {},\n\t    styleNode\n\t\n\t\n\tfunction getTag(dom) {\n\t  return tagImpl[dom.getAttribute('riot-tag') || dom.tagName.toLowerCase()]\n\t}\n\t\n\tfunction injectStyle(css) {\n\t\n\t  styleNode = styleNode || mkEl('style')\n\t\n\t  if (!document.head) return\n\t\n\t  if(styleNode.styleSheet)\n\t    styleNode.styleSheet.cssText += css\n\t  else\n\t    styleNode.innerHTML += css\n\t\n\t  if (!styleNode._rendered)\n\t    if (styleNode.styleSheet)\n\t      document.body.appendChild(styleNode)\n\t    else\n\t      document.head.appendChild(styleNode)\n\t\n\t  styleNode._rendered = true\n\t\n\t}\n\t\n\tfunction mountTo(root, tagName, opts) {\n\t  var tag = tagImpl[tagName],\n\t      innerHTML = root.innerHTML\n\t\n\t  // clear the inner html\n\t  root.innerHTML = ''\n\t\n\t  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)\n\t\n\t  if (tag && tag.mount) {\n\t    tag.mount()\n\t    virtualDom.push(tag)\n\t    return tag.on('unmount', function() {\n\t      virtualDom.splice(virtualDom.indexOf(tag), 1)\n\t    })\n\t  }\n\t\n\t}\n\t\n\triot.tag = function(name, html, css, attrs, fn) {\n\t  if (typeof attrs == 'function') {\n\t    fn = attrs\n\t    if(/^[\\w\\-]+\\s?=/.test(css)) {attrs = css; css = ''} else attrs = ''\n\t  }\n\t  if (typeof css == 'function') fn = css\n\t  else if (css) injectStyle(css)\n\t  tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n\t  return name\n\t}\n\t\n\triot.mount = function(selector, tagName, opts) {\n\t\n\t  var el,\n\t      selctAllTags = function() {\n\t        var keys = Object.keys(tagImpl)\n\t        var list = keys.join(', ')\n\t        each(keys, function(t) {\n\t          list += ', *[riot-tag=\"'+ t.trim() + '\"]'\n\t        })\n\t        return list\n\t      },\n\t      allTags,\n\t      tags = []\n\t\n\t  if (typeof tagName == 'object') { opts = tagName; tagName = 0 }\n\t\n\t  // crawl the DOM to find the tag\n\t  if(typeof selector == 'string') {\n\t    if (selector == '*') {\n\t      // select all the tags registered\n\t      // and also the tags found with the riot-tag attribute set\n\t      selector = allTags = selctAllTags()\n\t    } else {\n\t      selector.split(',').map(function(t) {\n\t        selector += ', *[riot-tag=\"'+ t.trim() + '\"]'\n\t      })\n\t\n\t    }\n\t    // or just the ones named like the selector\n\t    el = $$(selector)\n\t  }\n\t  // probably you have passed already a tag or a NodeList\n\t  else\n\t    el = selector\n\t\n\t  // select all the registered and mount them inside their root elements\n\t  if (tagName == '*') {\n\t    // get all custom tags\n\t    tagName = allTags || selctAllTags()\n\t    // if the root el it's just a single tag\n\t    if (el.tagName) {\n\t      el = $$(tagName, el)\n\t    } else {\n\t      var nodeList = []\n\t      // select all the children for all the different root elements\n\t      each(el, function(tag) {\n\t        nodeList = $$(tagName, tag)\n\t      })\n\t      el = nodeList\n\t    }\n\t    // get rid of the tagName\n\t    tagName = 0\n\t  }\n\t\n\t  function push(root) {\n\t    if(tagName && !root.getAttribute('riot-tag')) root.setAttribute('riot-tag', tagName)\n\t\n\t    var name = tagName || root.getAttribute('riot-tag') || root.tagName.toLowerCase(),\n\t        tag = mountTo(root, name, opts)\n\t\n\t    if (tag) tags.push(tag)\n\t  }\n\t\n\t  // DOM node\n\t  if (el.tagName)\n\t    push(selector)\n\t  // selector or NodeList\n\t  else\n\t    each(el, push)\n\t\n\t  return tags\n\t\n\t}\n\t\n\t// update everything\n\triot.update = function() {\n\t  return each(virtualDom, function(tag) {\n\t    tag.update()\n\t  })\n\t}\n\t\n\t// @deprecated\n\triot.mountTo = riot.mount\n\t\n\t\n\t  // share methods for other riot parts, e.g. compiler\n\t  riot.util = { brackets: brackets, tmpl: tmpl }\n\t\n\t  // support CommonJS, AMD & browser\n\t  if (true)\n\t    module.exports = riot\n\t  else if (typeof define === 'function' && define.amd)\n\t    define(function() { return riot })\n\t  else\n\t    window.riot = riot\n\t\n\t})(typeof window != 'undefined' ? window : undefined);\n\n\n/***/ },\n/* 2 */\n/*!************************************!*\\\n  !*** ./~/superagent/lib/client.js ***!\n  \\************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Module dependencies.\n\t */\n\t\n\tvar Emitter = __webpack_require__(/*! emitter */ 4);\n\tvar reduce = __webpack_require__(/*! reduce */ 5);\n\t\n\t/**\n\t * Root reference for iframes.\n\t */\n\t\n\tvar root = 'undefined' == typeof window\n\t  ? (this || self)\n\t  : window;\n\t\n\t/**\n\t * Noop.\n\t */\n\t\n\tfunction noop(){};\n\t\n\t/**\n\t * Check if `obj` is a host object,\n\t * we don't want to serialize these :)\n\t *\n\t * TODO: future proof, move to compoent land\n\t *\n\t * @param {Object} obj\n\t * @return {Boolean}\n\t * @api private\n\t */\n\t\n\tfunction isHost(obj) {\n\t  var str = {}.toString.call(obj);\n\t\n\t  switch (str) {\n\t    case '[object File]':\n\t    case '[object Blob]':\n\t    case '[object FormData]':\n\t      return true;\n\t    default:\n\t      return false;\n\t  }\n\t}\n\t\n\t/**\n\t * Determine XHR.\n\t */\n\t\n\trequest.getXHR = function () {\n\t  if (root.XMLHttpRequest\n\t      && (!root.location || 'file:' != root.location.protocol\n\t          || !root.ActiveXObject)) {\n\t    return new XMLHttpRequest;\n\t  } else {\n\t    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n\t    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n\t    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n\t    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n\t  }\n\t  return false;\n\t};\n\t\n\t/**\n\t * Removes leading and trailing whitespace, added to support IE.\n\t *\n\t * @param {String} s\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tvar trim = ''.trim\n\t  ? function(s) { return s.trim(); }\n\t  : function(s) { return s.replace(/(^\\s*|\\s*$)/g, ''); };\n\t\n\t/**\n\t * Check if `obj` is an object.\n\t *\n\t * @param {Object} obj\n\t * @return {Boolean}\n\t * @api private\n\t */\n\t\n\tfunction isObject(obj) {\n\t  return obj === Object(obj);\n\t}\n\t\n\t/**\n\t * Serialize the given `obj`.\n\t *\n\t * @param {Object} obj\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction serialize(obj) {\n\t  if (!isObject(obj)) return obj;\n\t  var pairs = [];\n\t  for (var key in obj) {\n\t    if (null != obj[key]) {\n\t      pairs.push(encodeURIComponent(key)\n\t        + '=' + encodeURIComponent(obj[key]));\n\t    }\n\t  }\n\t  return pairs.join('&');\n\t}\n\t\n\t/**\n\t * Expose serialization method.\n\t */\n\t\n\t request.serializeObject = serialize;\n\t\n\t /**\n\t  * Parse the given x-www-form-urlencoded `str`.\n\t  *\n\t  * @param {String} str\n\t  * @return {Object}\n\t  * @api private\n\t  */\n\t\n\tfunction parseString(str) {\n\t  var obj = {};\n\t  var pairs = str.split('&');\n\t  var parts;\n\t  var pair;\n\t\n\t  for (var i = 0, len = pairs.length; i < len; ++i) {\n\t    pair = pairs[i];\n\t    parts = pair.split('=');\n\t    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);\n\t  }\n\t\n\t  return obj;\n\t}\n\t\n\t/**\n\t * Expose parser.\n\t */\n\t\n\trequest.parseString = parseString;\n\t\n\t/**\n\t * Default MIME type map.\n\t *\n\t *     superagent.types.xml = 'application/xml';\n\t *\n\t */\n\t\n\trequest.types = {\n\t  html: 'text/html',\n\t  json: 'application/json',\n\t  xml: 'application/xml',\n\t  urlencoded: 'application/x-www-form-urlencoded',\n\t  'form': 'application/x-www-form-urlencoded',\n\t  'form-data': 'application/x-www-form-urlencoded'\n\t};\n\t\n\t/**\n\t * Default serialization map.\n\t *\n\t *     superagent.serialize['application/xml'] = function(obj){\n\t *       return 'generated xml here';\n\t *     };\n\t *\n\t */\n\t\n\t request.serialize = {\n\t   'application/x-www-form-urlencoded': serialize,\n\t   'application/json': JSON.stringify\n\t };\n\t\n\t /**\n\t  * Default parsers.\n\t  *\n\t  *     superagent.parse['application/xml'] = function(str){\n\t  *       return { object parsed from str };\n\t  *     };\n\t  *\n\t  */\n\t\n\trequest.parse = {\n\t  'application/x-www-form-urlencoded': parseString,\n\t  'application/json': JSON.parse\n\t};\n\t\n\t/**\n\t * Parse the given header `str` into\n\t * an object containing the mapped fields.\n\t *\n\t * @param {String} str\n\t * @return {Object}\n\t * @api private\n\t */\n\t\n\tfunction parseHeader(str) {\n\t  var lines = str.split(/\\r?\\n/);\n\t  var fields = {};\n\t  var index;\n\t  var line;\n\t  var field;\n\t  var val;\n\t\n\t  lines.pop(); // trailing CRLF\n\t\n\t  for (var i = 0, len = lines.length; i < len; ++i) {\n\t    line = lines[i];\n\t    index = line.indexOf(':');\n\t    field = line.slice(0, index).toLowerCase();\n\t    val = trim(line.slice(index + 1));\n\t    fields[field] = val;\n\t  }\n\t\n\t  return fields;\n\t}\n\t\n\t/**\n\t * Return the mime type for the given `str`.\n\t *\n\t * @param {String} str\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction type(str){\n\t  return str.split(/ *; */).shift();\n\t};\n\t\n\t/**\n\t * Return header field parameters.\n\t *\n\t * @param {String} str\n\t * @return {Object}\n\t * @api private\n\t */\n\t\n\tfunction params(str){\n\t  return reduce(str.split(/ *; */), function(obj, str){\n\t    var parts = str.split(/ *= */)\n\t      , key = parts.shift()\n\t      , val = parts.shift();\n\t\n\t    if (key && val) obj[key] = val;\n\t    return obj;\n\t  }, {});\n\t};\n\t\n\t/**\n\t * Initialize a new `Response` with the given `xhr`.\n\t *\n\t *  - set flags (.ok, .error, etc)\n\t *  - parse header\n\t *\n\t * Examples:\n\t *\n\t *  Aliasing `superagent` as `request` is nice:\n\t *\n\t *      request = superagent;\n\t *\n\t *  We can use the promise-like API, or pass callbacks:\n\t *\n\t *      request.get('/').end(function(res){});\n\t *      request.get('/', function(res){});\n\t *\n\t *  Sending data can be chained:\n\t *\n\t *      request\n\t *        .post('/user')\n\t *        .send({ name: 'tj' })\n\t *        .end(function(res){});\n\t *\n\t *  Or passed to `.send()`:\n\t *\n\t *      request\n\t *        .post('/user')\n\t *        .send({ name: 'tj' }, function(res){});\n\t *\n\t *  Or passed to `.post()`:\n\t *\n\t *      request\n\t *        .post('/user', { name: 'tj' })\n\t *        .end(function(res){});\n\t *\n\t * Or further reduced to a single call for simple cases:\n\t *\n\t *      request\n\t *        .post('/user', { name: 'tj' }, function(res){});\n\t *\n\t * @param {XMLHTTPRequest} xhr\n\t * @param {Object} options\n\t * @api private\n\t */\n\t\n\tfunction Response(req, options) {\n\t  options = options || {};\n\t  this.req = req;\n\t  this.xhr = this.req.xhr;\n\t  // responseText is accessible only if responseType is '' or 'text' and on older browsers\n\t  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')\n\t     ? this.xhr.responseText\n\t     : null;\n\t  this.statusText = this.req.xhr.statusText;\n\t  this.setStatusProperties(this.xhr.status);\n\t  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());\n\t  // getAllResponseHeaders sometimes falsely returns \"\" for CORS requests, but\n\t  // getResponseHeader still works. so we get content-type even if getting\n\t  // other headers fails.\n\t  this.header['content-type'] = this.xhr.getResponseHeader('content-type');\n\t  this.setHeaderProperties(this.header);\n\t  this.body = this.req.method != 'HEAD'\n\t    ? this.parseBody(this.text ? this.text : this.xhr.response)\n\t    : null;\n\t}\n\t\n\t/**\n\t * Get case-insensitive `field` value.\n\t *\n\t * @param {String} field\n\t * @return {String}\n\t * @api public\n\t */\n\t\n\tResponse.prototype.get = function(field){\n\t  return this.header[field.toLowerCase()];\n\t};\n\t\n\t/**\n\t * Set header related properties:\n\t *\n\t *   - `.type` the content type without params\n\t *\n\t * A response of \"Content-Type: text/plain; charset=utf-8\"\n\t * will provide you with a `.type` of \"text/plain\".\n\t *\n\t * @param {Object} header\n\t * @api private\n\t */\n\t\n\tResponse.prototype.setHeaderProperties = function(header){\n\t  // content-type\n\t  var ct = this.header['content-type'] || '';\n\t  this.type = type(ct);\n\t\n\t  // params\n\t  var obj = params(ct);\n\t  for (var key in obj) this[key] = obj[key];\n\t};\n\t\n\t/**\n\t * Parse the given body `str`.\n\t *\n\t * Used for auto-parsing of bodies. Parsers\n\t * are defined on the `superagent.parse` object.\n\t *\n\t * @param {String} str\n\t * @return {Mixed}\n\t * @api private\n\t */\n\t\n\tResponse.prototype.parseBody = function(str){\n\t  var parse = request.parse[this.type];\n\t  return parse && str && (str.length || str instanceof Object)\n\t    ? parse(str)\n\t    : null;\n\t};\n\t\n\t/**\n\t * Set flags such as `.ok` based on `status`.\n\t *\n\t * For example a 2xx response will give you a `.ok` of __true__\n\t * whereas 5xx will be __false__ and `.error` will be __true__. The\n\t * `.clientError` and `.serverError` are also available to be more\n\t * specific, and `.statusType` is the class of error ranging from 1..5\n\t * sometimes useful for mapping respond colors etc.\n\t *\n\t * \"sugar\" properties are also defined for common cases. Currently providing:\n\t *\n\t *   - .noContent\n\t *   - .badRequest\n\t *   - .unauthorized\n\t *   - .notAcceptable\n\t *   - .notFound\n\t *\n\t * @param {Number} status\n\t * @api private\n\t */\n\t\n\tResponse.prototype.setStatusProperties = function(status){\n\t  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n\t  if (status === 1223) {\n\t    status = 204;\n\t  }\n\t\n\t  var type = status / 100 | 0;\n\t\n\t  // status / class\n\t  this.status = status;\n\t  this.statusType = type;\n\t\n\t  // basics\n\t  this.info = 1 == type;\n\t  this.ok = 2 == type;\n\t  this.clientError = 4 == type;\n\t  this.serverError = 5 == type;\n\t  this.error = (4 == type || 5 == type)\n\t    ? this.toError()\n\t    : false;\n\t\n\t  // sugar\n\t  this.accepted = 202 == status;\n\t  this.noContent = 204 == status;\n\t  this.badRequest = 400 == status;\n\t  this.unauthorized = 401 == status;\n\t  this.notAcceptable = 406 == status;\n\t  this.notFound = 404 == status;\n\t  this.forbidden = 403 == status;\n\t};\n\t\n\t/**\n\t * Return an `Error` representative of this response.\n\t *\n\t * @return {Error}\n\t * @api public\n\t */\n\t\n\tResponse.prototype.toError = function(){\n\t  var req = this.req;\n\t  var method = req.method;\n\t  var url = req.url;\n\t\n\t  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';\n\t  var err = new Error(msg);\n\t  err.status = this.status;\n\t  err.method = method;\n\t  err.url = url;\n\t\n\t  return err;\n\t};\n\t\n\t/**\n\t * Expose `Response`.\n\t */\n\t\n\trequest.Response = Response;\n\t\n\t/**\n\t * Initialize a new `Request` with the given `method` and `url`.\n\t *\n\t * @param {String} method\n\t * @param {String} url\n\t * @api public\n\t */\n\t\n\tfunction Request(method, url) {\n\t  var self = this;\n\t  Emitter.call(this);\n\t  this._query = this._query || [];\n\t  this.method = method;\n\t  this.url = url;\n\t  this.header = {};\n\t  this._header = {};\n\t  this.on('end', function(){\n\t    var err = null;\n\t    var res = null;\n\t\n\t    try {\n\t      res = new Response(self);\n\t    } catch(e) {\n\t      err = new Error('Parser is unable to parse the response');\n\t      err.parse = true;\n\t      err.original = e;\n\t      return self.callback(err);\n\t    }\n\t\n\t    self.emit('response', res);\n\t\n\t    if (err) {\n\t      return self.callback(err, res);\n\t    }\n\t\n\t    if (res.status >= 200 && res.status < 300) {\n\t      return self.callback(err, res);\n\t    }\n\t\n\t    var new_err = new Error(res.statusText || 'Unsuccessful HTTP response');\n\t    new_err.original = err;\n\t    new_err.response = res;\n\t    new_err.status = res.status;\n\t\n\t    self.callback(err || new_err, res);\n\t  });\n\t}\n\t\n\t/**\n\t * Mixin `Emitter`.\n\t */\n\t\n\tEmitter(Request.prototype);\n\t\n\t/**\n\t * Allow for extension\n\t */\n\t\n\tRequest.prototype.use = function(fn) {\n\t  fn(this);\n\t  return this;\n\t}\n\t\n\t/**\n\t * Set timeout to `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.timeout = function(ms){\n\t  this._timeout = ms;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Clear previous timeout.\n\t *\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.clearTimeout = function(){\n\t  this._timeout = 0;\n\t  clearTimeout(this._timer);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Abort the request, and clear potential timeout.\n\t *\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\tRequest.prototype.abort = function(){\n\t  if (this.aborted) return;\n\t  this.aborted = true;\n\t  this.xhr.abort();\n\t  this.clearTimeout();\n\t  this.emit('abort');\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set header `field` to `val`, or multiple fields with one object.\n\t *\n\t * Examples:\n\t *\n\t *      req.get('/')\n\t *        .set('Accept', 'application/json')\n\t *        .set('X-API-Key', 'foobar')\n\t *        .end(callback);\n\t *\n\t *      req.get('/')\n\t *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })\n\t *        .end(callback);\n\t *\n\t * @param {String|Object} field\n\t * @param {String} val\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.set = function(field, val){\n\t  if (isObject(field)) {\n\t    for (var key in field) {\n\t      this.set(key, field[key]);\n\t    }\n\t    return this;\n\t  }\n\t  this._header[field.toLowerCase()] = val;\n\t  this.header[field] = val;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove header `field`.\n\t *\n\t * Example:\n\t *\n\t *      req.get('/')\n\t *        .unset('User-Agent')\n\t *        .end(callback);\n\t *\n\t * @param {String} field\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.unset = function(field){\n\t  delete this._header[field.toLowerCase()];\n\t  delete this.header[field];\n\t  return this;\n\t};\n\t\n\t/**\n\t * Get case-insensitive header `field` value.\n\t *\n\t * @param {String} field\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tRequest.prototype.getHeader = function(field){\n\t  return this._header[field.toLowerCase()];\n\t};\n\t\n\t/**\n\t * Set Content-Type to `type`, mapping values from `request.types`.\n\t *\n\t * Examples:\n\t *\n\t *      superagent.types.xml = 'application/xml';\n\t *\n\t *      request.post('/')\n\t *        .type('xml')\n\t *        .send(xmlstring)\n\t *        .end(callback);\n\t *\n\t *      request.post('/')\n\t *        .type('application/xml')\n\t *        .send(xmlstring)\n\t *        .end(callback);\n\t *\n\t * @param {String} type\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.type = function(type){\n\t  this.set('Content-Type', request.types[type] || type);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set Accept to `type`, mapping values from `request.types`.\n\t *\n\t * Examples:\n\t *\n\t *      superagent.types.json = 'application/json';\n\t *\n\t *      request.get('/agent')\n\t *        .accept('json')\n\t *        .end(callback);\n\t *\n\t *      request.get('/agent')\n\t *        .accept('application/json')\n\t *        .end(callback);\n\t *\n\t * @param {String} accept\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.accept = function(type){\n\t  this.set('Accept', request.types[type] || type);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Set Authorization field value with `user` and `pass`.\n\t *\n\t * @param {String} user\n\t * @param {String} pass\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.auth = function(user, pass){\n\t  var str = btoa(user + ':' + pass);\n\t  this.set('Authorization', 'Basic ' + str);\n\t  return this;\n\t};\n\t\n\t/**\n\t* Add query-string `val`.\n\t*\n\t* Examples:\n\t*\n\t*   request.get('/shoes')\n\t*     .query('size=10')\n\t*     .query({ color: 'blue' })\n\t*\n\t* @param {Object|String} val\n\t* @return {Request} for chaining\n\t* @api public\n\t*/\n\t\n\tRequest.prototype.query = function(val){\n\t  if ('string' != typeof val) val = serialize(val);\n\t  if (val) this._query.push(val);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Write the field `name` and `val` for \"multipart/form-data\"\n\t * request bodies.\n\t *\n\t * ``` js\n\t * request.post('/upload')\n\t *   .field('foo', 'bar')\n\t *   .end(callback);\n\t * ```\n\t *\n\t * @param {String} name\n\t * @param {String|Blob|File} val\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.field = function(name, val){\n\t  if (!this._formData) this._formData = new root.FormData();\n\t  this._formData.append(name, val);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Queue the given `file` as an attachment to the specified `field`,\n\t * with optional `filename`.\n\t *\n\t * ``` js\n\t * request.post('/upload')\n\t *   .attach(new Blob(['<a id=\"a\"><b id=\"b\">hey!</b></a>'], { type: \"text/html\"}))\n\t *   .end(callback);\n\t * ```\n\t *\n\t * @param {String} field\n\t * @param {Blob|File} file\n\t * @param {String} filename\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.attach = function(field, file, filename){\n\t  if (!this._formData) this._formData = new root.FormData();\n\t  this._formData.append(field, file, filename);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Send `data`, defaulting the `.type()` to \"json\" when\n\t * an object is given.\n\t *\n\t * Examples:\n\t *\n\t *       // querystring\n\t *       request.get('/search')\n\t *         .end(callback)\n\t *\n\t *       // multiple data \"writes\"\n\t *       request.get('/search')\n\t *         .send({ search: 'query' })\n\t *         .send({ range: '1..5' })\n\t *         .send({ order: 'desc' })\n\t *         .end(callback)\n\t *\n\t *       // manual json\n\t *       request.post('/user')\n\t *         .type('json')\n\t *         .send('{\"name\":\"tj\"})\n\t *         .end(callback)\n\t *\n\t *       // auto json\n\t *       request.post('/user')\n\t *         .send({ name: 'tj' })\n\t *         .end(callback)\n\t *\n\t *       // manual x-www-form-urlencoded\n\t *       request.post('/user')\n\t *         .type('form')\n\t *         .send('name=tj')\n\t *         .end(callback)\n\t *\n\t *       // auto x-www-form-urlencoded\n\t *       request.post('/user')\n\t *         .type('form')\n\t *         .send({ name: 'tj' })\n\t *         .end(callback)\n\t *\n\t *       // defaults to x-www-form-urlencoded\n\t  *      request.post('/user')\n\t  *        .send('name=tobi')\n\t  *        .send('species=ferret')\n\t  *        .end(callback)\n\t *\n\t * @param {String|Object} data\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.send = function(data){\n\t  var obj = isObject(data);\n\t  var type = this.getHeader('Content-Type');\n\t\n\t  // merge\n\t  if (obj && isObject(this._data)) {\n\t    for (var key in data) {\n\t      this._data[key] = data[key];\n\t    }\n\t  } else if ('string' == typeof data) {\n\t    if (!type) this.type('form');\n\t    type = this.getHeader('Content-Type');\n\t    if ('application/x-www-form-urlencoded' == type) {\n\t      this._data = this._data\n\t        ? this._data + '&' + data\n\t        : data;\n\t    } else {\n\t      this._data = (this._data || '') + data;\n\t    }\n\t  } else {\n\t    this._data = data;\n\t  }\n\t\n\t  if (!obj || isHost(data)) return this;\n\t  if (!type) this.type('json');\n\t  return this;\n\t};\n\t\n\t/**\n\t * Invoke the callback with `err` and `res`\n\t * and handle arity check.\n\t *\n\t * @param {Error} err\n\t * @param {Response} res\n\t * @api private\n\t */\n\t\n\tRequest.prototype.callback = function(err, res){\n\t  var fn = this._callback;\n\t  this.clearTimeout();\n\t  fn(err, res);\n\t};\n\t\n\t/**\n\t * Invoke callback with x-domain error.\n\t *\n\t * @api private\n\t */\n\t\n\tRequest.prototype.crossDomainError = function(){\n\t  var err = new Error('Origin is not allowed by Access-Control-Allow-Origin');\n\t  err.crossDomain = true;\n\t  this.callback(err);\n\t};\n\t\n\t/**\n\t * Invoke callback with timeout error.\n\t *\n\t * @api private\n\t */\n\t\n\tRequest.prototype.timeoutError = function(){\n\t  var timeout = this._timeout;\n\t  var err = new Error('timeout of ' + timeout + 'ms exceeded');\n\t  err.timeout = timeout;\n\t  this.callback(err);\n\t};\n\t\n\t/**\n\t * Enable transmission of cookies with x-domain requests.\n\t *\n\t * Note that for this to work the origin must not be\n\t * using \"Access-Control-Allow-Origin\" with a wildcard,\n\t * and also must set \"Access-Control-Allow-Credentials\"\n\t * to \"true\".\n\t *\n\t * @api public\n\t */\n\t\n\tRequest.prototype.withCredentials = function(){\n\t  this._withCredentials = true;\n\t  return this;\n\t};\n\t\n\t/**\n\t * Initiate request, invoking callback `fn(res)`\n\t * with an instanceof `Response`.\n\t *\n\t * @param {Function} fn\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\t\n\tRequest.prototype.end = function(fn){\n\t  var self = this;\n\t  var xhr = this.xhr = request.getXHR();\n\t  var query = this._query.join('&');\n\t  var timeout = this._timeout;\n\t  var data = this._formData || this._data;\n\t\n\t  // store callback\n\t  this._callback = fn || noop;\n\t\n\t  // state change\n\t  xhr.onreadystatechange = function(){\n\t    if (4 != xhr.readyState) return;\n\t\n\t    // In IE9, reads to any property (e.g. status) off of an aborted XHR will\n\t    // result in the error \"Could not complete the operation due to error c00c023f\"\n\t    var status;\n\t    try { status = xhr.status } catch(e) { status = 0; }\n\t\n\t    if (0 == status) {\n\t      if (self.timedout) return self.timeoutError();\n\t      if (self.aborted) return;\n\t      return self.crossDomainError();\n\t    }\n\t    self.emit('end');\n\t  };\n\t\n\t  // progress\n\t  var handleProgress = function(e){\n\t    if (e.total > 0) {\n\t      e.percent = e.loaded / e.total * 100;\n\t    }\n\t    self.emit('progress', e);\n\t  };\n\t  if (this.hasListeners('progress')) {\n\t    xhr.onprogress = handleProgress;\n\t  }\n\t  try {\n\t    if (xhr.upload && this.hasListeners('progress')) {\n\t      xhr.upload.onprogress = handleProgress;\n\t    }\n\t  } catch(e) {\n\t    // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.\n\t    // Reported here:\n\t    // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context\n\t  }\n\t\n\t  // timeout\n\t  if (timeout && !this._timer) {\n\t    this._timer = setTimeout(function(){\n\t      self.timedout = true;\n\t      self.abort();\n\t    }, timeout);\n\t  }\n\t\n\t  // querystring\n\t  if (query) {\n\t    query = request.serializeObject(query);\n\t    this.url += ~this.url.indexOf('?')\n\t      ? '&' + query\n\t      : '?' + query;\n\t  }\n\t\n\t  // initiate request\n\t  xhr.open(this.method, this.url, true);\n\t\n\t  // CORS\n\t  if (this._withCredentials) xhr.withCredentials = true;\n\t\n\t  // body\n\t  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {\n\t    // serialize stuff\n\t    var serialize = request.serialize[this.getHeader('Content-Type')];\n\t    if (serialize) data = serialize(data);\n\t  }\n\t\n\t  // set header fields\n\t  for (var field in this.header) {\n\t    if (null == this.header[field]) continue;\n\t    xhr.setRequestHeader(field, this.header[field]);\n\t  }\n\t\n\t  // send stuff\n\t  this.emit('request', this);\n\t  xhr.send(data);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Expose `Request`.\n\t */\n\t\n\trequest.Request = Request;\n\t\n\t/**\n\t * Issue a request:\n\t *\n\t * Examples:\n\t *\n\t *    request('GET', '/users').end(callback)\n\t *    request('/users').end(callback)\n\t *    request('/users', callback)\n\t *\n\t * @param {String} method\n\t * @param {String|Function} url or callback\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\tfunction request(method, url) {\n\t  // callback\n\t  if ('function' == typeof url) {\n\t    return new Request('GET', method).end(url);\n\t  }\n\t\n\t  // url first\n\t  if (1 == arguments.length) {\n\t    return new Request('GET', method);\n\t  }\n\t\n\t  return new Request(method, url);\n\t}\n\t\n\t/**\n\t * GET `url` with optional callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Mixed|Function} data or fn\n\t * @param {Function} fn\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\trequest.get = function(url, data, fn){\n\t  var req = request('GET', url);\n\t  if ('function' == typeof data) fn = data, data = null;\n\t  if (data) req.query(data);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\t\n\t/**\n\t * HEAD `url` with optional callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Mixed|Function} data or fn\n\t * @param {Function} fn\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\trequest.head = function(url, data, fn){\n\t  var req = request('HEAD', url);\n\t  if ('function' == typeof data) fn = data, data = null;\n\t  if (data) req.send(data);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\t\n\t/**\n\t * DELETE `url` with optional callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Function} fn\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\trequest.del = function(url, fn){\n\t  var req = request('DELETE', url);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\t\n\t/**\n\t * PATCH `url` with optional `data` and callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Mixed} data\n\t * @param {Function} fn\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\trequest.patch = function(url, data, fn){\n\t  var req = request('PATCH', url);\n\t  if ('function' == typeof data) fn = data, data = null;\n\t  if (data) req.send(data);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\t\n\t/**\n\t * POST `url` with optional `data` and callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Mixed} data\n\t * @param {Function} fn\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\trequest.post = function(url, data, fn){\n\t  var req = request('POST', url);\n\t  if ('function' == typeof data) fn = data, data = null;\n\t  if (data) req.send(data);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\t\n\t/**\n\t * PUT `url` with optional `data` and callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Mixed|Function} data or fn\n\t * @param {Function} fn\n\t * @return {Request}\n\t * @api public\n\t */\n\t\n\trequest.put = function(url, data, fn){\n\t  var req = request('PUT', url);\n\t  if ('function' == typeof data) fn = data, data = null;\n\t  if (data) req.send(data);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\t\n\t/**\n\t * Expose `request`.\n\t */\n\t\n\tmodule.exports = request;\n\n\n/***/ },\n/* 3 */,\n/* 4 */\n/*!***************************************************!*\\\n  !*** ./~/superagent/~/component-emitter/index.js ***!\n  \\***************************************************/\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * Expose `Emitter`.\n\t */\n\t\n\tmodule.exports = Emitter;\n\t\n\t/**\n\t * Initialize a new `Emitter`.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction Emitter(obj) {\n\t  if (obj) return mixin(obj);\n\t};\n\t\n\t/**\n\t * Mixin the emitter properties.\n\t *\n\t * @param {Object} obj\n\t * @return {Object}\n\t * @api private\n\t */\n\t\n\tfunction mixin(obj) {\n\t  for (var key in Emitter.prototype) {\n\t    obj[key] = Emitter.prototype[key];\n\t  }\n\t  return obj;\n\t}\n\t\n\t/**\n\t * Listen on the given `event` with `fn`.\n\t *\n\t * @param {String} event\n\t * @param {Function} fn\n\t * @return {Emitter}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.on =\n\tEmitter.prototype.addEventListener = function(event, fn){\n\t  this._callbacks = this._callbacks || {};\n\t  (this._callbacks[event] = this._callbacks[event] || [])\n\t    .push(fn);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Adds an `event` listener that will be invoked a single\n\t * time then automatically removed.\n\t *\n\t * @param {String} event\n\t * @param {Function} fn\n\t * @return {Emitter}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.once = function(event, fn){\n\t  var self = this;\n\t  this._callbacks = this._callbacks || {};\n\t\n\t  function on() {\n\t    self.off(event, on);\n\t    fn.apply(this, arguments);\n\t  }\n\t\n\t  on.fn = fn;\n\t  this.on(event, on);\n\t  return this;\n\t};\n\t\n\t/**\n\t * Remove the given callback for `event` or all\n\t * registered callbacks.\n\t *\n\t * @param {String} event\n\t * @param {Function} fn\n\t * @return {Emitter}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.off =\n\tEmitter.prototype.removeListener =\n\tEmitter.prototype.removeAllListeners =\n\tEmitter.prototype.removeEventListener = function(event, fn){\n\t  this._callbacks = this._callbacks || {};\n\t\n\t  // all\n\t  if (0 == arguments.length) {\n\t    this._callbacks = {};\n\t    return this;\n\t  }\n\t\n\t  // specific event\n\t  var callbacks = this._callbacks[event];\n\t  if (!callbacks) return this;\n\t\n\t  // remove all handlers\n\t  if (1 == arguments.length) {\n\t    delete this._callbacks[event];\n\t    return this;\n\t  }\n\t\n\t  // remove specific handler\n\t  var cb;\n\t  for (var i = 0; i < callbacks.length; i++) {\n\t    cb = callbacks[i];\n\t    if (cb === fn || cb.fn === fn) {\n\t      callbacks.splice(i, 1);\n\t      break;\n\t    }\n\t  }\n\t  return this;\n\t};\n\t\n\t/**\n\t * Emit `event` with the given args.\n\t *\n\t * @param {String} event\n\t * @param {Mixed} ...\n\t * @return {Emitter}\n\t */\n\t\n\tEmitter.prototype.emit = function(event){\n\t  this._callbacks = this._callbacks || {};\n\t  var args = [].slice.call(arguments, 1)\n\t    , callbacks = this._callbacks[event];\n\t\n\t  if (callbacks) {\n\t    callbacks = callbacks.slice(0);\n\t    for (var i = 0, len = callbacks.length; i < len; ++i) {\n\t      callbacks[i].apply(this, args);\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\t/**\n\t * Return array of callbacks for `event`.\n\t *\n\t * @param {String} event\n\t * @return {Array}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.listeners = function(event){\n\t  this._callbacks = this._callbacks || {};\n\t  return this._callbacks[event] || [];\n\t};\n\t\n\t/**\n\t * Check if this emitter has `event` handlers.\n\t *\n\t * @param {String} event\n\t * @return {Boolean}\n\t * @api public\n\t */\n\t\n\tEmitter.prototype.hasListeners = function(event){\n\t  return !! this.listeners(event).length;\n\t};\n\n\n/***/ },\n/* 5 */\n/*!**************************************************!*\\\n  !*** ./~/superagent/~/reduce-component/index.js ***!\n  \\**************************************************/\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * Reduce `arr` with `fn`.\n\t *\n\t * @param {Array} arr\n\t * @param {Function} fn\n\t * @param {Mixed} initial\n\t *\n\t * TODO: combatible error handling?\n\t */\n\t\n\tmodule.exports = function(arr, fn, initial){  \n\t  var idx = 0;\n\t  var len = arr.length;\n\t  var curr = arguments.length == 3\n\t    ? initial\n\t    : arr[idx++];\n\t\n\t  while (idx < len) {\n\t    curr = fn.call(null, curr, arr[idx], ++idx, arr);\n\t  }\n\t  \n\t  return curr;\n\t};\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** vendor.bundle.js\n **/"," \t// install a JSONP callback for chunk loading\n \tvar parentJsonpFunction = window[\"webpackJsonp\"];\n \twindow[\"webpackJsonp\"] = function webpackJsonpCallback(chunkIds, moreModules) {\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, callbacks = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId])\n \t\t\t\tcallbacks.push.apply(callbacks, installedChunks[chunkId]);\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);\n \t\twhile(callbacks.length)\n \t\t\tcallbacks.shift().call(null, __webpack_require__);\n \t\tif(moreModules[0]) {\n \t\t\tinstalledModules[0] = 0;\n \t\t\treturn __webpack_require__(0);\n \t\t}\n \t};\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// \"0\" means \"already loaded\"\n \t// Array means \"loading\", array contains callbacks\n \tvar installedChunks = {\n \t\t0:0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n \t\t// \"0\" is the signal for \"already loaded\"\n \t\tif(installedChunks[chunkId] === 0)\n \t\t\treturn callback.call(null, __webpack_require__);\n\n \t\t// an array means \"currently loading\".\n \t\tif(installedChunks[chunkId] !== undefined) {\n \t\t\tinstalledChunks[chunkId].push(callback);\n \t\t} else {\n \t\t\t// start chunk loading\n \t\t\tinstalledChunks[chunkId] = [callback];\n \t\t\tvar head = document.getElementsByTagName('head')[0];\n \t\t\tvar script = document.createElement('script');\n \t\t\tscript.type = 'text/javascript';\n \t\t\tscript.charset = 'utf-8';\n \t\t\tscript.async = true;\n\n \t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".bundle.js\";\n \t\t\thead.appendChild(script);\n \t\t}\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap bebe61747b6407c199c2\n **/","import 'riot'\nimport 'superagent/lib/client'\n\n\n\n/** WEBPACK FOOTER **\n ** ./static/src/vendor.js\n **/","/* Riot v2.1.0, @license MIT, (c) 2015 Muut Inc. + contributors */\n\n;(function(window) {\n  // 'use strict' does not allow us to override the events properties https://github.com/muut/riotjs/blob/dev/lib/tag/update.js#L7-L10\n  // it leads to the following error on firefox \"setting a property that has only a getter\"\n  //'use strict'\n\n\n  var riot = { version: 'v2.1.0', settings: {} }\n\n\nriot.observable = function(el) {\n\n  el = el || {}\n\n  var callbacks = {},\n      _id = 0\n\n  el.on = function(events, fn) {\n    if (typeof fn == 'function') {\n      fn._id = typeof fn._id == 'undefined' ? _id++ : fn._id\n\n      events.replace(/\\S+/g, function(name, pos) {\n        (callbacks[name] = callbacks[name] || []).push(fn)\n        fn.typed = pos > 0\n      })\n    }\n    return el\n  }\n\n  el.off = function(events, fn) {\n    if (events == '*') callbacks = {}\n    else {\n      events.replace(/\\S+/g, function(name) {\n        if (fn) {\n          var arr = callbacks[name]\n          for (var i = 0, cb; (cb = arr && arr[i]); ++i) {\n            if (cb._id == fn._id) { arr.splice(i, 1); i-- }\n          }\n        } else {\n          callbacks[name] = []\n        }\n      })\n    }\n    return el\n  }\n\n  // only single event supported\n  el.one = function(name, fn) {\n    function on() {\n      el.off(name, on)\n      fn.apply(el, arguments)\n    }\n    return el.on(name, on)\n  }\n\n  el.trigger = function(name) {\n    var args = [].slice.call(arguments, 1),\n        fns = callbacks[name] || []\n\n    for (var i = 0, fn; (fn = fns[i]); ++i) {\n      if (!fn.busy) {\n        fn.busy = 1\n        fn.apply(el, fn.typed ? [name].concat(args) : args)\n        if (fns[i] !== fn) { i-- }\n        fn.busy = 0\n      }\n    }\n\n    if (callbacks.all && name != 'all') {\n      el.trigger.apply(el, ['all', name].concat(args))\n    }\n\n    return el\n  }\n\n  return el\n\n}\nriot.mixin = (function() {\n  var registeredMixins = {}\n  return function(name, mixin) {\n    if (!mixin) return registeredMixins[name]\n      else registeredMixins[name] = mixin\n  }\n})()\n\n;(function(riot, evt, window) {\n\n  // browsers only\n  if (!window) return\n\n  var loc = window.location,\n      fns = riot.observable(),\n      win = window,\n      started = false,\n      current\n\n  function hash() {\n    return loc.href.split('#')[1] || ''\n  }\n\n  function parser(path) {\n    return path.split('/')\n  }\n\n  function emit(path) {\n    if (path.type) path = hash()\n\n    if (path != current) {\n      fns.trigger.apply(null, ['H'].concat(parser(path)))\n      current = path\n    }\n  }\n\n  var r = riot.route = function(arg) {\n    // string\n    if (arg[0]) {\n      loc.hash = arg\n      emit(arg)\n\n    // function\n    } else {\n      fns.on('H', arg)\n    }\n  }\n\n  r.exec = function(fn) {\n    fn.apply(null, parser(hash()))\n  }\n\n  r.parser = function(fn) {\n    parser = fn\n  }\n\n  r.stop = function () {\n    if (!started) return\n    win.removeEventListener ? win.removeEventListener(evt, emit, false) : win.detachEvent('on' + evt, emit)\n    fns.off('*')\n    started = false\n  }\n\n  r.start = function () {\n    if (started) return\n    win.addEventListener ? win.addEventListener(evt, emit, false) : win.attachEvent('on' + evt, emit)\n    started = true\n  }\n\n  // autostart the router\n  r.start()\n\n})(riot, 'hashchange', window)\n/*\n\n//// How it works?\n\n\nThree ways:\n\n1. Expressions: tmpl('{ value }', data).\n   Returns the result of evaluated expression as a raw object.\n\n2. Templates: tmpl('Hi { name } { surname }', data).\n   Returns a string with evaluated expressions.\n\n3. Filters: tmpl('{ show: !done, highlight: active }', data).\n   Returns a space separated list of trueish keys (mainly\n   used for setting html classes), e.g. \"show highlight\".\n\n\n// Template examples\n\ntmpl('{ title || \"Untitled\" }', data)\ntmpl('Results are { results ? \"ready\" : \"loading\" }', data)\ntmpl('Today is { new Date() }', data)\ntmpl('{ message.length > 140 && \"Message is too long\" }', data)\ntmpl('This item got { Math.round(rating) } stars', data)\ntmpl('<h1>{ title }</h1>{ body }', data)\n\n\n// Falsy expressions in templates\n\nIn templates (as opposed to single expressions) all falsy values\nexcept zero (undefined/null/false) will default to empty string:\n\ntmpl('{ undefined } - { false } - { null } - { 0 }', {})\n// will return: \" - - - 0\"\n\n*/\n\n\nvar brackets = (function(orig, s, b) {\n  return function(x) {\n\n    // make sure we use the current setting\n    s = riot.settings.brackets || orig\n    if (b != s) b = s.split(' ')\n\n    // if regexp given, rewrite it with current brackets (only if differ from default)\n    return x && x.test\n      ? s == orig\n        ? x : RegExp(x.source\n                      .replace(/\\{/g, b[0].replace(/(?=.)/g, '\\\\'))\n                      .replace(/\\}/g, b[1].replace(/(?=.)/g, '\\\\')),\n                    x.global ? 'g' : '')\n\n      // else, get specific bracket\n      : b[x]\n\n  }\n})('{ }')\n\n\nvar tmpl = (function() {\n\n  var cache = {},\n      reVars = /(['\"\\/]).*?[^\\\\]\\1|\\.\\w*|\\w*:|\\b(?:(?:new|typeof|in|instanceof) |(?:this|true|false|null|undefined)\\b|function *\\()|([a-z_$]\\w*)/gi\n              // [ 1               ][ 2  ][ 3 ][ 4                                                                                  ][ 5       ]\n              // find variable names:\n              // 1. skip quoted strings and regexps: \"a b\", 'a b', 'a \\'b\\'', /a b/\n              // 2. skip object properties: .name\n              // 3. skip object literals: name:\n              // 4. skip javascript keywords\n              // 5. match var name\n\n  // build a template (or get it from cache), render with data\n  return function(str, data) {\n    return str && (cache[str] = cache[str] || tmpl(str))(data)\n  }\n\n\n  // create a template instance\n\n  function tmpl(s, p) {\n\n    // default template string to {}\n    s = (s || (brackets(0) + brackets(1)))\n\n      // temporarily convert \\{ and \\} to a non-character\n      .replace(brackets(/\\\\{/g), '\\uFFF0')\n      .replace(brackets(/\\\\}/g), '\\uFFF1')\n\n    // split string to expression and non-expresion parts\n    p = split(s, extract(s, brackets(/{/), brackets(/}/)))\n\n    return new Function('d', 'return ' + (\n\n      // is it a single expression or a template? i.e. {x} or <b>{x}</b>\n      !p[0] && !p[2] && !p[3]\n\n        // if expression, evaluate it\n        ? expr(p[1])\n\n        // if template, evaluate all expressions in it\n        : '[' + p.map(function(s, i) {\n\n            // is it an expression or a string (every second part is an expression)\n          return i % 2\n\n              // evaluate the expressions\n              ? expr(s, true)\n\n              // process string parts of the template:\n              : '\"' + s\n\n                  // preserve new lines\n                  .replace(/\\n/g, '\\\\n')\n\n                  // escape quotes\n                  .replace(/\"/g, '\\\\\"')\n\n                + '\"'\n\n        }).join(',') + '].join(\"\")'\n      )\n\n      // bring escaped { and } back\n      .replace(/\\uFFF0/g, brackets(0))\n      .replace(/\\uFFF1/g, brackets(1))\n\n    + ';')\n\n  }\n\n\n  // parse { ... } expression\n\n  function expr(s, n) {\n    s = s\n\n      // convert new lines to spaces\n      .replace(/\\n/g, ' ')\n\n      // trim whitespace, brackets, strip comments\n      .replace(brackets(/^[{ ]+|[ }]+$|\\/\\*.+?\\*\\//g), '')\n\n    // is it an object literal? i.e. { key : value }\n    return /^\\s*[\\w- \"']+ *:/.test(s)\n\n      // if object literal, return trueish keys\n      // e.g.: { show: isOpen(), done: item.done } -> \"show done\"\n      ? '[' +\n\n          // extract key:val pairs, ignoring any nested objects\n          extract(s,\n\n              // name part: name:, \"name\":, 'name':, name :\n              /[\"' ]*[\\w- ]+[\"' ]*:/,\n\n              // expression part: everything upto a comma followed by a name (see above) or end of line\n              /,(?=[\"' ]*[\\w- ]+[\"' ]*:)|}|$/\n              ).map(function(pair) {\n\n                // get key, val parts\n                return pair.replace(/^[ \"']*(.+?)[ \"']*: *(.+?),? *$/, function(_, k, v) {\n\n                  // wrap all conditional parts to ignore errors\n                  return v.replace(/[^&|=!><]+/g, wrap) + '?\"' + k + '\":\"\",'\n\n                })\n\n              }).join('')\n\n        + '].join(\" \").trim()'\n\n      // if js expression, evaluate as javascript\n      : wrap(s, n)\n\n  }\n\n\n  // execute js w/o breaking on errors or undefined vars\n\n  function wrap(s, nonull) {\n    s = s.trim()\n    return !s ? '' : '(function(v){try{v='\n\n        // prefix vars (name => data.name)\n        + (s.replace(reVars, function(s, _, v) { return v ? '(d.'+v+'===undefined?'+(typeof window == 'undefined' ? 'global.' : 'window.')+v+':d.'+v+')' : s })\n\n          // break the expression if its empty (resulting in undefined value)\n          || 'x')\n      + '}catch(e){'\n      + '}finally{return '\n\n        // default to empty string for falsy values except zero\n        + (nonull === true ? '!v&&v!==0?\"\":v' : 'v')\n\n      + '}}).call(d)'\n  }\n\n\n  // split string by an array of substrings\n\n  function split(str, substrings) {\n    var parts = []\n    substrings.map(function(sub, i) {\n\n      // push matched expression and part before it\n      i = str.indexOf(sub)\n      parts.push(str.slice(0, i), sub)\n      str = str.slice(i + sub.length)\n    })\n\n    // push the remaining part\n    return parts.concat(str)\n  }\n\n\n  // match strings between opening and closing regexp, skipping any inner/nested matches\n\n  function extract(str, open, close) {\n\n    var start,\n        level = 0,\n        matches = [],\n        re = new RegExp('('+open.source+')|('+close.source+')', 'g')\n\n    str.replace(re, function(_, open, close, pos) {\n\n      // if outer inner bracket, mark position\n      if(!level && open) start = pos\n\n      // in(de)crease bracket level\n      level += open ? 1 : -1\n\n      // if outer closing bracket, grab the match\n      if(!level && close != null) matches.push(str.slice(start, pos+close.length))\n\n    })\n\n    return matches\n  }\n\n})()\n\n// { key, i in items} -> { key, i, items }\nfunction loopKeys(expr) {\n  var ret = { val: expr },\n      els = expr.split(/\\s+in\\s+/)\n\n  if (els[1]) {\n    ret.val = brackets(0) + els[1]\n    els = els[0].slice(brackets(0).length).trim().split(/,\\s*/)\n    ret.key = els[0]\n    ret.pos = els[1]\n  }\n\n  return ret\n}\n\nfunction mkitem(expr, key, val) {\n  var item = {}\n  item[expr.key] = key\n  if (expr.pos) item[expr.pos] = val\n  return item\n}\n\n\n/* Beware: heavy stuff */\nfunction _each(dom, parent, expr) {\n\n  remAttr(dom, 'each')\n\n  var template = dom.outerHTML,\n      prev = dom.previousSibling,\n      root = dom.parentNode,\n      rendered = [],\n      tags = [],\n      checksum\n\n  expr = loopKeys(expr)\n\n  function add(pos, item, tag) {\n    rendered.splice(pos, 0, item)\n    tags.splice(pos, 0, tag)\n  }\n\n  // clean template code\n  parent.one('update', function() {\n    root.removeChild(dom)\n\n  }).one('premount', function() {\n    if (root.stub) root = parent.root\n\n  }).on('update', function() {\n\n    var items = tmpl(expr.val, parent)\n    if (!items) return\n\n    // object loop. any changes cause full redraw\n    if (!Array.isArray(items)) {\n      var testsum = JSON.stringify(items)\n\n      if (testsum == checksum) return\n      checksum = testsum\n\n      // clear old items\n      each(tags, function(tag) { tag.unmount() })\n      rendered = []\n      tags = []\n\n      items = Object.keys(items).map(function(key) {\n        return mkitem(expr, key, items[key])\n      })\n\n    }\n\n    // unmount redundant\n    each(rendered, function(item) {\n      if (item instanceof Object) {\n        // skip existing items\n        if (items.indexOf(item) > -1) {\n          return\n        }\n      } else {\n        // find all non-objects\n        var newItems = arrFindEquals(items, item),\n            oldItems = arrFindEquals(rendered, item)\n\n        // if more or equal amount, no need to remove\n        if (newItems.length >= oldItems.length) {\n          return\n        }\n      }\n      var pos = rendered.indexOf(item),\n          tag = tags[pos]\n\n      if (tag) {\n        tag.unmount()\n        rendered.splice(pos, 1)\n        tags.splice(pos, 1)\n        // to let \"each\" know that this item is removed\n        return false\n      }\n\n    })\n\n    // mount new / reorder\n    var prevBase = [].indexOf.call(root.childNodes, prev) + 1\n    each(items, function(item, i) {\n\n      // start index search from position based on the current i\n      var pos = items.indexOf(item, i),\n          oldPos = rendered.indexOf(item, i)\n\n      // if not found, search backwards from current i position\n      pos < 0 && (pos = items.lastIndexOf(item, i))\n      oldPos < 0 && (oldPos = rendered.lastIndexOf(item, i))\n\n      if (!(item instanceof Object)) {\n        // find all non-objects\n        var newItems = arrFindEquals(items, item),\n            oldItems = arrFindEquals(rendered, item)\n\n        // if more, should mount one new\n        if (newItems.length > oldItems.length) {\n          oldPos = -1\n        }\n      }\n\n      // mount new\n      var nodes = root.childNodes\n      if (oldPos < 0) {\n        if (!checksum && expr.key) var _item = mkitem(expr, item, pos)\n\n        var tag = new Tag({ tmpl: template }, {\n          before: nodes[prevBase + pos],\n          parent: parent,\n          root: root,\n          item: _item || item\n        })\n\n        tag.mount()\n\n        add(pos, item, tag)\n        return true\n      }\n\n      // change pos value\n      if (expr.pos && tags[oldPos][expr.pos] != pos) {\n        tags[oldPos].one('update', function(item) {\n          item[expr.pos] = pos\n        })\n        tags[oldPos].update()\n      }\n\n      // reorder\n      if (pos != oldPos) {\n        root.insertBefore(nodes[prevBase + oldPos], nodes[prevBase + (pos > oldPos ? pos + 1 : pos)])\n        return add(pos, rendered.splice(oldPos, 1)[0], tags.splice(oldPos, 1)[0])\n      }\n\n    })\n\n    rendered = items.slice()\n\n  }).one('updated', function() {\n    walk(root, function(dom) {\n      each(dom.attributes, function(attr) {\n        if (/^(name|id)$/.test(attr.name)) parent[attr.value] = dom\n      })\n    })\n  })\n\n}\n\n\nfunction parseNamedElements(root, parent, childTags) {\n\n  walk(root, function(dom) {\n    if (dom.nodeType == 1) {\n      dom.isLoop = 0\n      if(dom.parentNode && dom.parentNode.isLoop) dom.isLoop = 1\n      if(dom.getAttribute('each')) dom.isLoop = 1\n      // custom child tag\n      var child = getTag(dom)\n\n      if (child && !dom.isLoop) {\n        var tag = new Tag(child, { root: dom, parent: parent }, dom.innerHTML),\n            namedTag = dom.getAttribute('name'),\n            tagName = namedTag && namedTag.indexOf(brackets(0)) < 0 ? namedTag : child.name,\n            ptag = parent,\n            cachedTag\n\n        while(!getTag(ptag.root)) {\n          if(!ptag.parent) break\n          ptag = ptag.parent\n        }\n        // fix for the parent attribute in the looped elements\n        tag.parent = ptag\n\n        cachedTag = ptag.tags[tagName]\n\n        // if there are multiple children tags having the same name\n        if (cachedTag) {\n          // if the parent tags property is not yet an array\n          // create it adding the first cached tag\n          if (!Array.isArray(cachedTag))\n            ptag.tags[tagName] = [cachedTag]\n          // add the new nested tag to the array\n          ptag.tags[tagName].push(tag)\n        } else {\n          ptag.tags[tagName] = tag\n        }\n\n        // empty the child node once we got its template\n        // to avoid that its children get compiled multiple times\n        dom.innerHTML = ''\n        childTags.push(tag)\n      }\n\n      if(!dom.isLoop)\n        each(dom.attributes, function(attr) {\n          if (/^(name|id)$/.test(attr.name)) parent[attr.value] = dom\n        })\n    }\n\n  })\n\n}\n\nfunction parseExpressions(root, tag, expressions) {\n\n  function addExpr(dom, val, extra) {\n    if (val.indexOf(brackets(0)) >= 0) {\n      var expr = { dom: dom, expr: val }\n      expressions.push(extend(expr, extra))\n    }\n  }\n\n  walk(root, function(dom) {\n    var type = dom.nodeType\n\n    // text node\n    if (type == 3 && dom.parentNode.tagName != 'STYLE') addExpr(dom, dom.nodeValue)\n    if (type != 1) return\n\n    /* element */\n\n    // loop\n    var attr = dom.getAttribute('each')\n    if (attr) { _each(dom, tag, attr); return false }\n\n    // attribute expressions\n    each(dom.attributes, function(attr) {\n      var name = attr.name,\n        bool = name.split('__')[1]\n\n      addExpr(dom, attr.value, { attr: bool || name, bool: bool })\n      if (bool) { remAttr(dom, name); return false }\n\n    })\n\n    // skip custom tags\n    if (getTag(dom)) return false\n\n  })\n\n}\nfunction Tag(impl, conf, innerHTML) {\n\n  var self = riot.observable(this),\n      opts = inherit(conf.opts) || {},\n      dom = mkdom(impl.tmpl),\n      parent = conf.parent,\n      expressions = [],\n      childTags = [],\n      root = conf.root,\n      item = conf.item,\n      fn = impl.fn,\n      tagName = root.tagName.toLowerCase(),\n      attr = {},\n      loopDom,\n      TAG_ATTRIBUTES = /([\\w\\-]+)\\s?=\\s?['\"]([^'\"]+)[\"']/gim\n\n  if (fn && root._tag) {\n    root._tag.unmount(true)\n  }\n\n  if(impl.attrs) {\n    var attrs = impl.attrs.match(TAG_ATTRIBUTES)\n\n    each(attrs, function(a) {\n      var kv = a.split(/\\s?=\\s?/)\n      root.setAttribute(kv[0], kv[1].replace(/['\"]/g, ''))\n    })\n\n  }\n  // keep a reference to the tag just created\n  // so we will be able to mount this tag multiple times\n  root._tag = this\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  this._id = fastAbs(~~(new Date().getTime() * Math.random()))\n\n  extend(this, { parent: parent, root: root, opts: opts, tags: {} }, item)\n\n  // grab attributes\n  each(root.attributes, function(el) {\n    attr[el.name] = el.value\n  })\n\n\n  if (dom.innerHTML && !/select/.test(tagName) && !/tbody/.test(tagName) && !/tr/.test(tagName))\n    // replace all the yield tags with the tag inner html\n    dom.innerHTML = replaceYield(dom.innerHTML, innerHTML)\n\n\n  // options\n  function updateOpts() {\n    each(Object.keys(attr), function(name) {\n      opts[name] = tmpl(attr[name], parent || self)\n    })\n  }\n\n  this.update = function(data, init) {\n    extend(self, data, item)\n    updateOpts()\n    self.trigger('update', item)\n    update(expressions, self, item)\n    self.trigger('updated')\n  }\n\n  this.mixin = function() {\n    each(arguments, function(mix) {\n      mix = 'string' == typeof mix ? riot.mixin(mix) : mix\n      each(Object.keys(mix), function(key) {\n        // bind methods to self\n        if ('init' != key)\n          self[key] = 'function' == typeof mix[key] ? mix[key].bind(self) : mix[key]\n      })\n      // init method will be called automatically\n      if (mix.init) mix.init.bind(self)()\n    })\n  }\n\n  this.mount = function() {\n\n    updateOpts()\n\n    // initialiation\n    fn && fn.call(self, opts)\n\n    toggle(true)\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions(dom, self, expressions)\n\n    if (!self.parent) self.update()\n\n    // internal use only, fixes #403\n    self.trigger('premount')\n\n    if (fn) {\n      while (dom.firstChild) root.appendChild(dom.firstChild)\n\n    } else {\n      loopDom = dom.firstChild\n      root.insertBefore(loopDom, conf.before || null) // null needed for IE8\n    }\n\n    if (root.stub) self.root = root = parent.root\n\n    // if it's not a child tag we can trigger its mount event\n    if (!self.parent) self.trigger('mount')\n    // otherwise we need to wait that the parent event gets triggered\n    else self.parent.one('mount', function() { self.trigger('mount') })\n  }\n\n\n  this.unmount = function(keepRootTag) {\n    var el = fn ? root : loopDom,\n        p = el.parentNode\n\n    if (p) {\n\n      if (parent) {\n        // remove this tag from the parent tags object\n        // if there are multiple nested tags with same name..\n        // remove this element form the array\n        if (Array.isArray(parent.tags[tagName])) {\n          each(parent.tags[tagName], function(tag, i) {\n            if (tag._id == self._id)\n              parent.tags[tagName].splice(i, 1)\n          })\n        } else\n          // otherwise just delete the tag instance\n          parent.tags[tagName] = undefined\n      } else {\n        while (el.firstChild) el.removeChild(el.firstChild)\n      }\n\n      if (!keepRootTag)\n        p.removeChild(el)\n\n    }\n\n\n    self.trigger('unmount')\n    toggle()\n    self.off('*')\n    // somehow ie8 does not like `delete root._tag`\n    root._tag = null\n\n  }\n\n  function toggle(isMount) {\n\n    // mount/unmount children\n    each(childTags, function(child) { child[isMount ? 'mount' : 'unmount']() })\n\n    // listen/unlisten parent (events flow one way from parent to children)\n    if (parent) {\n      var evt = isMount ? 'on' : 'off'\n      parent[evt]('update', self.update)[evt]('unmount', self.unmount)\n    }\n  }\n\n  // named elements available for fn\n  parseNamedElements(dom, this, childTags)\n\n\n}\n\nfunction setEventHandler(name, handler, dom, tag, item) {\n\n  dom[name] = function(e) {\n\n    // cross browser event fix\n    e = e || window.event\n    e.which = e.which || e.charCode || e.keyCode\n    e.target = e.target || e.srcElement\n    e.currentTarget = dom\n    e.item = item\n\n    // prevent default behaviour (by default)\n    if (handler.call(tag, e) !== true && !/radio|check/.test(dom.type)) {\n      e.preventDefault && e.preventDefault()\n      e.returnValue = false\n    }\n\n    if (!e.preventUpdate) {\n      var el = item ? tag.parent : tag\n      el.update()\n    }\n\n  }\n\n}\n\n// used by if- attribute\nfunction insertTo(root, node, before) {\n  if (root) {\n    root.insertBefore(before, node)\n    root.removeChild(node)\n  }\n}\n\n// item = currently looped item\nfunction update(expressions, tag, item) {\n\n  each(expressions, function(expr, i) {\n\n    var dom = expr.dom,\n        attrName = expr.attr,\n        value = tmpl(expr.expr, tag),\n        parent = expr.dom.parentNode\n\n    if (value == null) value = ''\n\n    // leave out riot- prefixes from strings inside textarea\n    if (parent && parent.tagName == 'TEXTAREA') value = value.replace(/riot-/g, '')\n\n    // no change\n    if (expr.value === value) return\n    expr.value = value\n\n    // text node\n    if (!attrName) return dom.nodeValue = value.toString()\n\n    // remove original attribute\n    remAttr(dom, attrName)\n\n    // event handler\n    if (typeof value == 'function') {\n      setEventHandler(attrName, value, dom, tag, item)\n\n    // if- conditional\n    } else if (attrName == 'if') {\n      var stub = expr.stub\n\n      // add to DOM\n      if (value) {\n        stub && insertTo(stub.parentNode, stub, dom)\n\n      // remove from DOM\n      } else {\n        stub = expr.stub = stub || document.createTextNode('')\n        insertTo(dom.parentNode, dom, stub)\n      }\n\n    // show / hide\n    } else if (/^(show|hide)$/.test(attrName)) {\n      if (attrName == 'hide') value = !value\n      dom.style.display = value ? '' : 'none'\n\n    // field value\n    } else if (attrName == 'value') {\n      dom.value = value\n\n    // <img src=\"{ expr }\">\n    } else if (attrName.slice(0, 5) == 'riot-') {\n      attrName = attrName.slice(5)\n      value ? dom.setAttribute(attrName, value) : remAttr(dom, attrName)\n\n    } else {\n      if (expr.bool) {\n        dom[attrName] = value\n        if (!value) return\n        value = attrName\n      }\n\n      if (typeof value != 'object') dom.setAttribute(attrName, value)\n\n    }\n\n  })\n\n}\n\nfunction each(els, fn) {\n  for (var i = 0, len = (els || []).length, el; i < len; i++) {\n    el = els[i]\n    // return false -> remove current item during loop\n    if (el != null && fn(el, i) === false) i--\n  }\n  return els\n}\n\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name)\n}\n\nfunction fastAbs(nr) {\n  return (nr ^ (nr >> 31)) - (nr >> 31)\n}\n\n// max 2 from objects allowed\nfunction extend(obj, from, from2) {\n  from && each(Object.keys(from), function(key) {\n    obj[key] = from[key]\n  })\n  return from2 ? extend(obj, from2) : obj\n}\n\nfunction checkIE() {\n  if (window) {\n    var ua = navigator.userAgent\n    var msie = ua.indexOf('MSIE ')\n    if (msie > 0) {\n      return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10)\n    }\n    else {\n      return 0\n    }\n  }\n}\n\nfunction optionInnerHTML(el, html) {\n  var opt = document.createElement('option'),\n      valRegx = /value=[\\\"'](.+?)[\\\"']/,\n      selRegx = /selected=[\\\"'](.+?)[\\\"']/,\n      valuesMatch = html.match(valRegx),\n      selectedMatch = html.match(selRegx)\n\n  opt.innerHTML = html\n\n  if (valuesMatch) {\n    opt.value = valuesMatch[1]\n  }\n\n  if (selectedMatch) {\n    opt.setAttribute('riot-selected', selectedMatch[1])\n  }\n\n  el.appendChild(opt)\n}\n\nfunction tbodyInnerHTML(el, html, tagName) {\n  var div = document.createElement('div')\n  div.innerHTML = '<table>' + html + '</table>'\n\n  if (/td|th/.test(tagName)) {\n    el.appendChild(div.firstChild.firstChild.firstChild.firstChild)\n  } else {\n    el.appendChild(div.firstChild.firstChild.firstChild)\n  }\n}\n\nfunction mkdom(template) {\n  var tagName = template.trim().slice(1, 3).toLowerCase(),\n      rootTag = /td|th/.test(tagName) ? 'tr' : tagName == 'tr' ? 'tbody' : 'div',\n      el = mkEl(rootTag)\n\n  el.stub = true\n\n  if (tagName === 'op' && ieVersion && ieVersion < 10) {\n    optionInnerHTML(el, template)\n  } else if ((rootTag === 'tbody' || rootTag === 'tr') && ieVersion && ieVersion < 10) {\n    tbodyInnerHTML(el, template, tagName)\n  } else\n    el.innerHTML = template\n\n  return el\n}\n\nfunction walk(dom, fn) {\n  if (dom) {\n    if (fn(dom) === false) walk(dom.nextSibling, fn)\n    else {\n      dom = dom.firstChild\n\n      while (dom) {\n        walk(dom, fn)\n        dom = dom.nextSibling\n      }\n    }\n  }\n}\n\nfunction mkEl(name) {\n  return document.createElement(name)\n}\n\nfunction replaceYield (tmpl, innerHTML) {\n  return tmpl.replace(/<(yield)\\/?>(<\\/\\1>)?/gim, innerHTML || '')\n}\n\nfunction $$(selector, ctx) {\n  ctx = ctx || document\n  return ctx.querySelectorAll(selector)\n}\n\nfunction arrDiff(arr1, arr2) {\n  return arr1.filter(function(el) {\n    return arr2.indexOf(el) < 0\n  })\n}\n\nfunction arrFindEquals(arr, el) {\n  return arr.filter(function (_el) {\n    return _el === el\n  })\n}\n\nfunction inherit(parent) {\n  function Child() {}\n  Child.prototype = parent\n  return new Child()\n}\n/**\n *\n * Hacks needed for the old internet explorer versions [lower than IE10]\n *\n */\n\nvar ieVersion = checkIE()\n\nfunction checkIE() {\n  if (window) {\n    var ua = navigator.userAgent\n    var msie = ua.indexOf('MSIE ')\n    if (msie > 0) {\n      return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10)\n    }\n    else {\n      return 0\n    }\n  }\n}\n\nfunction tbodyInnerHTML(el, html, tagName) {\n  var div = mkEl('div'),\n      loops = /td|th/.test(tagName) ? 3 : 2,\n      child\n\n  div.innerHTML = '<table>' + html + '</table>'\n  child = div.firstChild\n\n  while(loops--) {\n    child = child.firstChild\n  }\n\n  el.appendChild(child)\n\n}\n\nfunction optionInnerHTML(el, html) {\n  var opt = mkEl('option'),\n      valRegx = /value=[\\\"'](.+?)[\\\"']/,\n      selRegx = /selected=[\\\"'](.+?)[\\\"']/,\n      valuesMatch = html.match(valRegx),\n      selectedMatch = html.match(selRegx)\n\n  opt.innerHTML = html\n\n  if (valuesMatch) {\n    opt.value = valuesMatch[1]\n  }\n\n  if (selectedMatch) {\n    opt.setAttribute('riot-selected', selectedMatch[1])\n  }\n\n  el.appendChild(opt)\n}\n\n/*\n Virtual dom is an array of custom tags on the document.\n Updates and unmounts propagate downwards from parent to children.\n*/\n\nvar virtualDom = [],\n    tagImpl = {},\n    styleNode\n\n\nfunction getTag(dom) {\n  return tagImpl[dom.getAttribute('riot-tag') || dom.tagName.toLowerCase()]\n}\n\nfunction injectStyle(css) {\n\n  styleNode = styleNode || mkEl('style')\n\n  if (!document.head) return\n\n  if(styleNode.styleSheet)\n    styleNode.styleSheet.cssText += css\n  else\n    styleNode.innerHTML += css\n\n  if (!styleNode._rendered)\n    if (styleNode.styleSheet)\n      document.body.appendChild(styleNode)\n    else\n      document.head.appendChild(styleNode)\n\n  styleNode._rendered = true\n\n}\n\nfunction mountTo(root, tagName, opts) {\n  var tag = tagImpl[tagName],\n      innerHTML = root.innerHTML\n\n  // clear the inner html\n  root.innerHTML = ''\n\n  if (tag && root) tag = new Tag(tag, { root: root, opts: opts }, innerHTML)\n\n  if (tag && tag.mount) {\n    tag.mount()\n    virtualDom.push(tag)\n    return tag.on('unmount', function() {\n      virtualDom.splice(virtualDom.indexOf(tag), 1)\n    })\n  }\n\n}\n\nriot.tag = function(name, html, css, attrs, fn) {\n  if (typeof attrs == 'function') {\n    fn = attrs\n    if(/^[\\w\\-]+\\s?=/.test(css)) {attrs = css; css = ''} else attrs = ''\n  }\n  if (typeof css == 'function') fn = css\n  else if (css) injectStyle(css)\n  tagImpl[name] = { name: name, tmpl: html, attrs: attrs, fn: fn }\n  return name\n}\n\nriot.mount = function(selector, tagName, opts) {\n\n  var el,\n      selctAllTags = function() {\n        var keys = Object.keys(tagImpl)\n        var list = keys.join(', ')\n        each(keys, function(t) {\n          list += ', *[riot-tag=\"'+ t.trim() + '\"]'\n        })\n        return list\n      },\n      allTags,\n      tags = []\n\n  if (typeof tagName == 'object') { opts = tagName; tagName = 0 }\n\n  // crawl the DOM to find the tag\n  if(typeof selector == 'string') {\n    if (selector == '*') {\n      // select all the tags registered\n      // and also the tags found with the riot-tag attribute set\n      selector = allTags = selctAllTags()\n    } else {\n      selector.split(',').map(function(t) {\n        selector += ', *[riot-tag=\"'+ t.trim() + '\"]'\n      })\n\n    }\n    // or just the ones named like the selector\n    el = $$(selector)\n  }\n  // probably you have passed already a tag or a NodeList\n  else\n    el = selector\n\n  // select all the registered and mount them inside their root elements\n  if (tagName == '*') {\n    // get all custom tags\n    tagName = allTags || selctAllTags()\n    // if the root el it's just a single tag\n    if (el.tagName) {\n      el = $$(tagName, el)\n    } else {\n      var nodeList = []\n      // select all the children for all the different root elements\n      each(el, function(tag) {\n        nodeList = $$(tagName, tag)\n      })\n      el = nodeList\n    }\n    // get rid of the tagName\n    tagName = 0\n  }\n\n  function push(root) {\n    if(tagName && !root.getAttribute('riot-tag')) root.setAttribute('riot-tag', tagName)\n\n    var name = tagName || root.getAttribute('riot-tag') || root.tagName.toLowerCase(),\n        tag = mountTo(root, name, opts)\n\n    if (tag) tags.push(tag)\n  }\n\n  // DOM node\n  if (el.tagName)\n    push(selector)\n  // selector or NodeList\n  else\n    each(el, push)\n\n  return tags\n\n}\n\n// update everything\nriot.update = function() {\n  return each(virtualDom, function(tag) {\n    tag.update()\n  })\n}\n\n// @deprecated\nriot.mountTo = riot.mount\n\n\n  // share methods for other riot parts, e.g. compiler\n  riot.util = { brackets: brackets, tmpl: tmpl }\n\n  // support CommonJS, AMD & browser\n  if (typeof exports === 'object')\n    module.exports = riot\n  else if (typeof define === 'function' && define.amd)\n    define(function() { return riot })\n  else\n    window.riot = riot\n\n})(typeof window != 'undefined' ? window : undefined);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/riot/riot.js\n ** module id = 1\n ** module chunks = 0\n **/","/**\n * Module dependencies.\n */\n\nvar Emitter = require('emitter');\nvar reduce = require('reduce');\n\n/**\n * Root reference for iframes.\n */\n\nvar root = 'undefined' == typeof window\n  ? (this || self)\n  : window;\n\n/**\n * Noop.\n */\n\nfunction noop(){};\n\n/**\n * Check if `obj` is a host object,\n * we don't want to serialize these :)\n *\n * TODO: future proof, move to compoent land\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isHost(obj) {\n  var str = {}.toString.call(obj);\n\n  switch (str) {\n    case '[object File]':\n    case '[object Blob]':\n    case '[object FormData]':\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Determine XHR.\n */\n\nrequest.getXHR = function () {\n  if (root.XMLHttpRequest\n      && (!root.location || 'file:' != root.location.protocol\n          || !root.ActiveXObject)) {\n    return new XMLHttpRequest;\n  } else {\n    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n  }\n  return false;\n};\n\n/**\n * Removes leading and trailing whitespace, added to support IE.\n *\n * @param {String} s\n * @return {String}\n * @api private\n */\n\nvar trim = ''.trim\n  ? function(s) { return s.trim(); }\n  : function(s) { return s.replace(/(^\\s*|\\s*$)/g, ''); };\n\n/**\n * Check if `obj` is an object.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isObject(obj) {\n  return obj === Object(obj);\n}\n\n/**\n * Serialize the given `obj`.\n *\n * @param {Object} obj\n * @return {String}\n * @api private\n */\n\nfunction serialize(obj) {\n  if (!isObject(obj)) return obj;\n  var pairs = [];\n  for (var key in obj) {\n    if (null != obj[key]) {\n      pairs.push(encodeURIComponent(key)\n        + '=' + encodeURIComponent(obj[key]));\n    }\n  }\n  return pairs.join('&');\n}\n\n/**\n * Expose serialization method.\n */\n\n request.serializeObject = serialize;\n\n /**\n  * Parse the given x-www-form-urlencoded `str`.\n  *\n  * @param {String} str\n  * @return {Object}\n  * @api private\n  */\n\nfunction parseString(str) {\n  var obj = {};\n  var pairs = str.split('&');\n  var parts;\n  var pair;\n\n  for (var i = 0, len = pairs.length; i < len; ++i) {\n    pair = pairs[i];\n    parts = pair.split('=');\n    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);\n  }\n\n  return obj;\n}\n\n/**\n * Expose parser.\n */\n\nrequest.parseString = parseString;\n\n/**\n * Default MIME type map.\n *\n *     superagent.types.xml = 'application/xml';\n *\n */\n\nrequest.types = {\n  html: 'text/html',\n  json: 'application/json',\n  xml: 'application/xml',\n  urlencoded: 'application/x-www-form-urlencoded',\n  'form': 'application/x-www-form-urlencoded',\n  'form-data': 'application/x-www-form-urlencoded'\n};\n\n/**\n * Default serialization map.\n *\n *     superagent.serialize['application/xml'] = function(obj){\n *       return 'generated xml here';\n *     };\n *\n */\n\n request.serialize = {\n   'application/x-www-form-urlencoded': serialize,\n   'application/json': JSON.stringify\n };\n\n /**\n  * Default parsers.\n  *\n  *     superagent.parse['application/xml'] = function(str){\n  *       return { object parsed from str };\n  *     };\n  *\n  */\n\nrequest.parse = {\n  'application/x-www-form-urlencoded': parseString,\n  'application/json': JSON.parse\n};\n\n/**\n * Parse the given header `str` into\n * an object containing the mapped fields.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction parseHeader(str) {\n  var lines = str.split(/\\r?\\n/);\n  var fields = {};\n  var index;\n  var line;\n  var field;\n  var val;\n\n  lines.pop(); // trailing CRLF\n\n  for (var i = 0, len = lines.length; i < len; ++i) {\n    line = lines[i];\n    index = line.indexOf(':');\n    field = line.slice(0, index).toLowerCase();\n    val = trim(line.slice(index + 1));\n    fields[field] = val;\n  }\n\n  return fields;\n}\n\n/**\n * Return the mime type for the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nfunction type(str){\n  return str.split(/ *; */).shift();\n};\n\n/**\n * Return header field parameters.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction params(str){\n  return reduce(str.split(/ *; */), function(obj, str){\n    var parts = str.split(/ *= */)\n      , key = parts.shift()\n      , val = parts.shift();\n\n    if (key && val) obj[key] = val;\n    return obj;\n  }, {});\n};\n\n/**\n * Initialize a new `Response` with the given `xhr`.\n *\n *  - set flags (.ok, .error, etc)\n *  - parse header\n *\n * Examples:\n *\n *  Aliasing `superagent` as `request` is nice:\n *\n *      request = superagent;\n *\n *  We can use the promise-like API, or pass callbacks:\n *\n *      request.get('/').end(function(res){});\n *      request.get('/', function(res){});\n *\n *  Sending data can be chained:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' })\n *        .end(function(res){});\n *\n *  Or passed to `.send()`:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' }, function(res){});\n *\n *  Or passed to `.post()`:\n *\n *      request\n *        .post('/user', { name: 'tj' })\n *        .end(function(res){});\n *\n * Or further reduced to a single call for simple cases:\n *\n *      request\n *        .post('/user', { name: 'tj' }, function(res){});\n *\n * @param {XMLHTTPRequest} xhr\n * @param {Object} options\n * @api private\n */\n\nfunction Response(req, options) {\n  options = options || {};\n  this.req = req;\n  this.xhr = this.req.xhr;\n  // responseText is accessible only if responseType is '' or 'text' and on older browsers\n  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')\n     ? this.xhr.responseText\n     : null;\n  this.statusText = this.req.xhr.statusText;\n  this.setStatusProperties(this.xhr.status);\n  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());\n  // getAllResponseHeaders sometimes falsely returns \"\" for CORS requests, but\n  // getResponseHeader still works. so we get content-type even if getting\n  // other headers fails.\n  this.header['content-type'] = this.xhr.getResponseHeader('content-type');\n  this.setHeaderProperties(this.header);\n  this.body = this.req.method != 'HEAD'\n    ? this.parseBody(this.text ? this.text : this.xhr.response)\n    : null;\n}\n\n/**\n * Get case-insensitive `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nResponse.prototype.get = function(field){\n  return this.header[field.toLowerCase()];\n};\n\n/**\n * Set header related properties:\n *\n *   - `.type` the content type without params\n *\n * A response of \"Content-Type: text/plain; charset=utf-8\"\n * will provide you with a `.type` of \"text/plain\".\n *\n * @param {Object} header\n * @api private\n */\n\nResponse.prototype.setHeaderProperties = function(header){\n  // content-type\n  var ct = this.header['content-type'] || '';\n  this.type = type(ct);\n\n  // params\n  var obj = params(ct);\n  for (var key in obj) this[key] = obj[key];\n};\n\n/**\n * Parse the given body `str`.\n *\n * Used for auto-parsing of bodies. Parsers\n * are defined on the `superagent.parse` object.\n *\n * @param {String} str\n * @return {Mixed}\n * @api private\n */\n\nResponse.prototype.parseBody = function(str){\n  var parse = request.parse[this.type];\n  return parse && str && (str.length || str instanceof Object)\n    ? parse(str)\n    : null;\n};\n\n/**\n * Set flags such as `.ok` based on `status`.\n *\n * For example a 2xx response will give you a `.ok` of __true__\n * whereas 5xx will be __false__ and `.error` will be __true__. The\n * `.clientError` and `.serverError` are also available to be more\n * specific, and `.statusType` is the class of error ranging from 1..5\n * sometimes useful for mapping respond colors etc.\n *\n * \"sugar\" properties are also defined for common cases. Currently providing:\n *\n *   - .noContent\n *   - .badRequest\n *   - .unauthorized\n *   - .notAcceptable\n *   - .notFound\n *\n * @param {Number} status\n * @api private\n */\n\nResponse.prototype.setStatusProperties = function(status){\n  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n  if (status === 1223) {\n    status = 204;\n  }\n\n  var type = status / 100 | 0;\n\n  // status / class\n  this.status = status;\n  this.statusType = type;\n\n  // basics\n  this.info = 1 == type;\n  this.ok = 2 == type;\n  this.clientError = 4 == type;\n  this.serverError = 5 == type;\n  this.error = (4 == type || 5 == type)\n    ? this.toError()\n    : false;\n\n  // sugar\n  this.accepted = 202 == status;\n  this.noContent = 204 == status;\n  this.badRequest = 400 == status;\n  this.unauthorized = 401 == status;\n  this.notAcceptable = 406 == status;\n  this.notFound = 404 == status;\n  this.forbidden = 403 == status;\n};\n\n/**\n * Return an `Error` representative of this response.\n *\n * @return {Error}\n * @api public\n */\n\nResponse.prototype.toError = function(){\n  var req = this.req;\n  var method = req.method;\n  var url = req.url;\n\n  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';\n  var err = new Error(msg);\n  err.status = this.status;\n  err.method = method;\n  err.url = url;\n\n  return err;\n};\n\n/**\n * Expose `Response`.\n */\n\nrequest.Response = Response;\n\n/**\n * Initialize a new `Request` with the given `method` and `url`.\n *\n * @param {String} method\n * @param {String} url\n * @api public\n */\n\nfunction Request(method, url) {\n  var self = this;\n  Emitter.call(this);\n  this._query = this._query || [];\n  this.method = method;\n  this.url = url;\n  this.header = {};\n  this._header = {};\n  this.on('end', function(){\n    var err = null;\n    var res = null;\n\n    try {\n      res = new Response(self);\n    } catch(e) {\n      err = new Error('Parser is unable to parse the response');\n      err.parse = true;\n      err.original = e;\n      return self.callback(err);\n    }\n\n    self.emit('response', res);\n\n    if (err) {\n      return self.callback(err, res);\n    }\n\n    if (res.status >= 200 && res.status < 300) {\n      return self.callback(err, res);\n    }\n\n    var new_err = new Error(res.statusText || 'Unsuccessful HTTP response');\n    new_err.original = err;\n    new_err.response = res;\n    new_err.status = res.status;\n\n    self.callback(err || new_err, res);\n  });\n}\n\n/**\n * Mixin `Emitter`.\n */\n\nEmitter(Request.prototype);\n\n/**\n * Allow for extension\n */\n\nRequest.prototype.use = function(fn) {\n  fn(this);\n  return this;\n}\n\n/**\n * Set timeout to `ms`.\n *\n * @param {Number} ms\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.timeout = function(ms){\n  this._timeout = ms;\n  return this;\n};\n\n/**\n * Clear previous timeout.\n *\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.clearTimeout = function(){\n  this._timeout = 0;\n  clearTimeout(this._timer);\n  return this;\n};\n\n/**\n * Abort the request, and clear potential timeout.\n *\n * @return {Request}\n * @api public\n */\n\nRequest.prototype.abort = function(){\n  if (this.aborted) return;\n  this.aborted = true;\n  this.xhr.abort();\n  this.clearTimeout();\n  this.emit('abort');\n  return this;\n};\n\n/**\n * Set header `field` to `val`, or multiple fields with one object.\n *\n * Examples:\n *\n *      req.get('/')\n *        .set('Accept', 'application/json')\n *        .set('X-API-Key', 'foobar')\n *        .end(callback);\n *\n *      req.get('/')\n *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })\n *        .end(callback);\n *\n * @param {String|Object} field\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.set = function(field, val){\n  if (isObject(field)) {\n    for (var key in field) {\n      this.set(key, field[key]);\n    }\n    return this;\n  }\n  this._header[field.toLowerCase()] = val;\n  this.header[field] = val;\n  return this;\n};\n\n/**\n * Remove header `field`.\n *\n * Example:\n *\n *      req.get('/')\n *        .unset('User-Agent')\n *        .end(callback);\n *\n * @param {String} field\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.unset = function(field){\n  delete this._header[field.toLowerCase()];\n  delete this.header[field];\n  return this;\n};\n\n/**\n * Get case-insensitive header `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api private\n */\n\nRequest.prototype.getHeader = function(field){\n  return this._header[field.toLowerCase()];\n};\n\n/**\n * Set Content-Type to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.xml = 'application/xml';\n *\n *      request.post('/')\n *        .type('xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n *      request.post('/')\n *        .type('application/xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n * @param {String} type\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.type = function(type){\n  this.set('Content-Type', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Accept to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.json = 'application/json';\n *\n *      request.get('/agent')\n *        .accept('json')\n *        .end(callback);\n *\n *      request.get('/agent')\n *        .accept('application/json')\n *        .end(callback);\n *\n * @param {String} accept\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.accept = function(type){\n  this.set('Accept', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Authorization field value with `user` and `pass`.\n *\n * @param {String} user\n * @param {String} pass\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.auth = function(user, pass){\n  var str = btoa(user + ':' + pass);\n  this.set('Authorization', 'Basic ' + str);\n  return this;\n};\n\n/**\n* Add query-string `val`.\n*\n* Examples:\n*\n*   request.get('/shoes')\n*     .query('size=10')\n*     .query({ color: 'blue' })\n*\n* @param {Object|String} val\n* @return {Request} for chaining\n* @api public\n*/\n\nRequest.prototype.query = function(val){\n  if ('string' != typeof val) val = serialize(val);\n  if (val) this._query.push(val);\n  return this;\n};\n\n/**\n * Write the field `name` and `val` for \"multipart/form-data\"\n * request bodies.\n *\n * ``` js\n * request.post('/upload')\n *   .field('foo', 'bar')\n *   .end(callback);\n * ```\n *\n * @param {String} name\n * @param {String|Blob|File} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.field = function(name, val){\n  if (!this._formData) this._formData = new root.FormData();\n  this._formData.append(name, val);\n  return this;\n};\n\n/**\n * Queue the given `file` as an attachment to the specified `field`,\n * with optional `filename`.\n *\n * ``` js\n * request.post('/upload')\n *   .attach(new Blob(['<a id=\"a\"><b id=\"b\">hey!</b></a>'], { type: \"text/html\"}))\n *   .end(callback);\n * ```\n *\n * @param {String} field\n * @param {Blob|File} file\n * @param {String} filename\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.attach = function(field, file, filename){\n  if (!this._formData) this._formData = new root.FormData();\n  this._formData.append(field, file, filename);\n  return this;\n};\n\n/**\n * Send `data`, defaulting the `.type()` to \"json\" when\n * an object is given.\n *\n * Examples:\n *\n *       // querystring\n *       request.get('/search')\n *         .end(callback)\n *\n *       // multiple data \"writes\"\n *       request.get('/search')\n *         .send({ search: 'query' })\n *         .send({ range: '1..5' })\n *         .send({ order: 'desc' })\n *         .end(callback)\n *\n *       // manual json\n *       request.post('/user')\n *         .type('json')\n *         .send('{\"name\":\"tj\"})\n *         .end(callback)\n *\n *       // auto json\n *       request.post('/user')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // manual x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send('name=tj')\n *         .end(callback)\n *\n *       // auto x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // defaults to x-www-form-urlencoded\n  *      request.post('/user')\n  *        .send('name=tobi')\n  *        .send('species=ferret')\n  *        .end(callback)\n *\n * @param {String|Object} data\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.send = function(data){\n  var obj = isObject(data);\n  var type = this.getHeader('Content-Type');\n\n  // merge\n  if (obj && isObject(this._data)) {\n    for (var key in data) {\n      this._data[key] = data[key];\n    }\n  } else if ('string' == typeof data) {\n    if (!type) this.type('form');\n    type = this.getHeader('Content-Type');\n    if ('application/x-www-form-urlencoded' == type) {\n      this._data = this._data\n        ? this._data + '&' + data\n        : data;\n    } else {\n      this._data = (this._data || '') + data;\n    }\n  } else {\n    this._data = data;\n  }\n\n  if (!obj || isHost(data)) return this;\n  if (!type) this.type('json');\n  return this;\n};\n\n/**\n * Invoke the callback with `err` and `res`\n * and handle arity check.\n *\n * @param {Error} err\n * @param {Response} res\n * @api private\n */\n\nRequest.prototype.callback = function(err, res){\n  var fn = this._callback;\n  this.clearTimeout();\n  fn(err, res);\n};\n\n/**\n * Invoke callback with x-domain error.\n *\n * @api private\n */\n\nRequest.prototype.crossDomainError = function(){\n  var err = new Error('Origin is not allowed by Access-Control-Allow-Origin');\n  err.crossDomain = true;\n  this.callback(err);\n};\n\n/**\n * Invoke callback with timeout error.\n *\n * @api private\n */\n\nRequest.prototype.timeoutError = function(){\n  var timeout = this._timeout;\n  var err = new Error('timeout of ' + timeout + 'ms exceeded');\n  err.timeout = timeout;\n  this.callback(err);\n};\n\n/**\n * Enable transmission of cookies with x-domain requests.\n *\n * Note that for this to work the origin must not be\n * using \"Access-Control-Allow-Origin\" with a wildcard,\n * and also must set \"Access-Control-Allow-Credentials\"\n * to \"true\".\n *\n * @api public\n */\n\nRequest.prototype.withCredentials = function(){\n  this._withCredentials = true;\n  return this;\n};\n\n/**\n * Initiate request, invoking callback `fn(res)`\n * with an instanceof `Response`.\n *\n * @param {Function} fn\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.end = function(fn){\n  var self = this;\n  var xhr = this.xhr = request.getXHR();\n  var query = this._query.join('&');\n  var timeout = this._timeout;\n  var data = this._formData || this._data;\n\n  // store callback\n  this._callback = fn || noop;\n\n  // state change\n  xhr.onreadystatechange = function(){\n    if (4 != xhr.readyState) return;\n\n    // In IE9, reads to any property (e.g. status) off of an aborted XHR will\n    // result in the error \"Could not complete the operation due to error c00c023f\"\n    var status;\n    try { status = xhr.status } catch(e) { status = 0; }\n\n    if (0 == status) {\n      if (self.timedout) return self.timeoutError();\n      if (self.aborted) return;\n      return self.crossDomainError();\n    }\n    self.emit('end');\n  };\n\n  // progress\n  var handleProgress = function(e){\n    if (e.total > 0) {\n      e.percent = e.loaded / e.total * 100;\n    }\n    self.emit('progress', e);\n  };\n  if (this.hasListeners('progress')) {\n    xhr.onprogress = handleProgress;\n  }\n  try {\n    if (xhr.upload && this.hasListeners('progress')) {\n      xhr.upload.onprogress = handleProgress;\n    }\n  } catch(e) {\n    // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.\n    // Reported here:\n    // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context\n  }\n\n  // timeout\n  if (timeout && !this._timer) {\n    this._timer = setTimeout(function(){\n      self.timedout = true;\n      self.abort();\n    }, timeout);\n  }\n\n  // querystring\n  if (query) {\n    query = request.serializeObject(query);\n    this.url += ~this.url.indexOf('?')\n      ? '&' + query\n      : '?' + query;\n  }\n\n  // initiate request\n  xhr.open(this.method, this.url, true);\n\n  // CORS\n  if (this._withCredentials) xhr.withCredentials = true;\n\n  // body\n  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {\n    // serialize stuff\n    var serialize = request.serialize[this.getHeader('Content-Type')];\n    if (serialize) data = serialize(data);\n  }\n\n  // set header fields\n  for (var field in this.header) {\n    if (null == this.header[field]) continue;\n    xhr.setRequestHeader(field, this.header[field]);\n  }\n\n  // send stuff\n  this.emit('request', this);\n  xhr.send(data);\n  return this;\n};\n\n/**\n * Expose `Request`.\n */\n\nrequest.Request = Request;\n\n/**\n * Issue a request:\n *\n * Examples:\n *\n *    request('GET', '/users').end(callback)\n *    request('/users').end(callback)\n *    request('/users', callback)\n *\n * @param {String} method\n * @param {String|Function} url or callback\n * @return {Request}\n * @api public\n */\n\nfunction request(method, url) {\n  // callback\n  if ('function' == typeof url) {\n    return new Request('GET', method).end(url);\n  }\n\n  // url first\n  if (1 == arguments.length) {\n    return new Request('GET', method);\n  }\n\n  return new Request(method, url);\n}\n\n/**\n * GET `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.get = function(url, data, fn){\n  var req = request('GET', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.query(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * HEAD `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.head = function(url, data, fn){\n  var req = request('HEAD', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * DELETE `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.del = function(url, fn){\n  var req = request('DELETE', url);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * PATCH `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} data\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.patch = function(url, data, fn){\n  var req = request('PATCH', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * POST `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} data\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.post = function(url, data, fn){\n  var req = request('POST', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * PUT `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.put = function(url, data, fn){\n  var req = request('PUT', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * Expose `request`.\n */\n\nmodule.exports = request;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/superagent/lib/client.js\n ** module id = 2\n ** module chunks = 0\n **/","\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  var self = this;\n  this._callbacks = this._callbacks || {};\n\n  function on() {\n    self.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks[event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/superagent/~/component-emitter/index.js\n ** module id = 4\n ** module chunks = 0\n **/","\n/**\n * Reduce `arr` with `fn`.\n *\n * @param {Array} arr\n * @param {Function} fn\n * @param {Mixed} initial\n *\n * TODO: combatible error handling?\n */\n\nmodule.exports = function(arr, fn, initial){  \n  var idx = 0;\n  var len = arr.length;\n  var curr = arguments.length == 3\n    ? initial\n    : arr[idx++];\n\n  while (idx < len) {\n    curr = fn.call(null, curr, arr[idx], ++idx, arr);\n  }\n  \n  return curr;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/superagent/~/reduce-component/index.js\n ** module id = 5\n ** module chunks = 0\n **/"],"sourceRoot":""}